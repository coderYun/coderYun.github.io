<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>coderYun</title>
  
  <subtitle>To Be Better</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-07-23T15:28:52.201Z</updated>
  <id>http://example.com/</id>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>剑指offer系列</title>
    <link href="http://example.com/2021/07/19/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97/"/>
    <id>http://example.com/2021/07/19/%E5%89%91%E6%8C%87offer%E7%B3%BB%E5%88%97/</id>
    <published>2021-07-19T15:37:58.000Z</published>
    <updated>2021-07-23T15:28:52.201Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h3 id="剑指offer"><a href="#剑指offer" class="headerlink" title="剑指offer"></a>剑指offer</h3><h4 id="1-JZ1"><a href="#1-JZ1" class="headerlink" title="1.JZ1"></a>1.JZ1</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&amp;&amp;tqId=11154&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # 在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</span></span><br><span class="line"><span class="comment"># # [</span></span><br><span class="line"><span class="comment"># #   [1,2,8,9],</span></span><br><span class="line"><span class="comment"># #   [2,4,9,12],</span></span><br><span class="line"><span class="comment"># #   [4,7,10,13],</span></span><br><span class="line"><span class="comment"># #   [6,8,11,15]</span></span><br><span class="line"><span class="comment"># # ]</span></span><br><span class="line"><span class="comment"># # 给定 target = 7，返回 true。</span></span><br><span class="line"><span class="comment"># # 给定 target = 3，返回 false。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.暴力搜索 + 二分查找</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find1</span>(<span class="params">target, array</span>):</span></span><br><span class="line">    <span class="comment"># 空值判断</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> array <span class="keyword">or</span> <span class="keyword">not</span> array[<span class="number">0</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(array)):</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(array[i])-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (right-left) / <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> target == array[i][mid]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> target &gt; array[i][mid]:</span><br><span class="line">                left = mid +<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid -<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.从右上角开始寻找，大于target就一定在下方，小于target就一定在左边</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find2</span>(<span class="params">target, array</span>):</span></span><br><span class="line">    <span class="comment"># 空值判断</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> array <span class="keyword">or</span> <span class="keyword">not</span> array[<span class="number">0</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    row = <span class="number">0</span></span><br><span class="line">    col = <span class="built_in">len</span>(array[<span class="number">0</span>])-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> row &lt;=<span class="built_in">len</span>(array)-<span class="number">1</span> <span class="keyword">and</span> col &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> target == array[row][col]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> target &gt; array[row][col]:</span><br><span class="line">            row += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            col -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        </span><br></pre></td></tr></table></figure><h4 id="2-JZ2"><a href="#2-JZ2" class="headerlink" title="2.JZ2"></a>2.JZ2</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://www.nowcoder.com/practice/0e26e5551f2b489b9f58bc83aa4b6c68?tpId=13&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 描述</span></span><br><span class="line"><span class="comment"># 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例1</span></span><br><span class="line"><span class="comment"># 输入：</span></span><br><span class="line"><span class="comment"># &quot;We Are Happy&quot;</span></span><br><span class="line"><span class="comment"># 复制</span></span><br><span class="line"><span class="comment"># 返回值：</span></span><br><span class="line"><span class="comment"># &quot;We%20Are%20Happy</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.直接调用内置函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">replaceSpace1</span>(<span class="params">s</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    <span class="keyword">return</span> s.replace(<span class="string">&quot; &quot;</span>, <span class="string">&quot;%20&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.遍历替换时间</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">replaceSpace2</span>(<span class="params">s</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> ss <span class="keyword">in</span> s:</span><br><span class="line">        res.append(ss) <span class="keyword">if</span> ss != <span class="string">&quot; &quot;</span> <span class="keyword">else</span> res.append(<span class="string">&quot;%20&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(res)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-JZ3"><a href="#3-JZ3" class="headerlink" title="3.JZ3"></a>3.JZ3</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 描述</span></span><br><span class="line"><span class="comment"># 输入一个链表的头节点，按链表从尾到头的顺序返回每个节点的值（用数组返回）。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 0 &lt;= 链表长度 &lt;= 1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例1</span></span><br><span class="line"><span class="comment"># 输入：</span></span><br><span class="line"><span class="comment"># &#123;1,2,3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回值：</span></span><br><span class="line"><span class="comment"># [3,2,1]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例2</span></span><br><span class="line"><span class="comment"># 输入：</span></span><br><span class="line"><span class="comment"># &#123;67,0,24,58&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回值：</span></span><br><span class="line"><span class="comment"># [58,24,0,67]</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1.直接顺序遍历得到的结果反向切片输出</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printListFromTailToHead1</span>(<span class="params">listNode</span>):</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> listNode:</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    cur = listNode</span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        res.append(cur.val)</span><br><span class="line">        cur = cur.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> res[::-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.先反转链表然后顺便遍历得到结果</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rever_list</span>(<span class="params">listNode</span>):</span></span><br><span class="line">    dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">    dummy.<span class="built_in">next</span> = listNode</span><br><span class="line">    pre = dummy</span><br><span class="line">    cur = listNode</span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        tmp = cur.<span class="built_in">next</span></span><br><span class="line">        cur.<span class="built_in">next</span> = pre</span><br><span class="line">        pre = cur</span><br><span class="line">        cur = tmp</span><br><span class="line">    <span class="keyword">return</span> pre</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printListFromTailToHead2</span>(<span class="params">listNode</span>):</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> listNode:</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    new_node = rever_list(listNode)</span><br><span class="line">    cur = new_node</span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        res.append(cur.val)</span><br><span class="line">        cur = cur.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.利用栈现进后出的性质，顺序遍历链表存入栈中，再pop出来</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printListFromTailToHead3</span>(<span class="params">listNode</span>):</span></span><br><span class="line">    stack = []</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> listNode:</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    cur = listNode</span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        stack.append(cur.val)</span><br><span class="line">        cur = cur.<span class="built_in">next</span></span><br><span class="line">    <span class="comment"># pop出栈中元素</span></span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        res.append(stack.pop())</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-JZ4"><a href="#4-JZ4" class="headerlink" title="4.JZ4"></a>4.JZ4</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给定某二叉树的前序遍历和中序遍历，请重建出该二叉树并返回它的头结点。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例1</span></span><br><span class="line"><span class="comment"># 输入：</span></span><br><span class="line"><span class="comment"># [1,2,4,7,3,5,6,8],[4,7,2,1,5,3,8,6]</span></span><br><span class="line"><span class="comment"># 返回值：</span></span><br><span class="line"><span class="comment"># &#123;1,2,3,4,#,5,6,#,7,#,#,8&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：</span></span><br><span class="line"><span class="comment"># 返回根节点，系统会输出整颗二叉树对比结果     </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例2</span></span><br><span class="line"><span class="comment"># 输入：</span></span><br><span class="line"><span class="comment"># [1],[1]</span></span><br><span class="line"><span class="comment"># 返回值：</span></span><br><span class="line"><span class="comment"># &#123;1&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例3</span></span><br><span class="line"><span class="comment"># 输入：</span></span><br><span class="line"><span class="comment"># [1,2,3,4,5,6,7],[3,2,4,1,6,5,7]</span></span><br><span class="line"><span class="comment"># 返回值：</span></span><br><span class="line"><span class="comment"># &#123;1,2,5,3,4,6,7&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分析:</span></span><br><span class="line"><span class="comment"># 根据中序遍历和前序遍历可以确定二叉树，具体过程为：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据前序序列第一个结点确定根结点</span></span><br><span class="line"><span class="comment"># 根据根结点在中序序列中的位置分割出左右两个子序列</span></span><br><span class="line"><span class="comment"># 对左子树和右子树分别递归使用同样的方法继续分解</span></span><br><span class="line"><span class="comment"># 例如：</span></span><br><span class="line"><span class="comment"># 前序序列&#123;1,2,4,7,3,5,6,8&#125; = pre</span></span><br><span class="line"><span class="comment"># 中序序列&#123;4,7,2,1,5,3,8,6&#125; = in</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据当前前序序列的第一个结点确定根结点，为 1</span></span><br><span class="line"><span class="comment"># 找到 1 在中序遍历序列中的位置，为 in[3]</span></span><br><span class="line"><span class="comment"># 切割左右子树，则 in[3] 前面的为左子树， in[3] 后面的为右子树</span></span><br><span class="line"><span class="comment"># 则切割后的左子树前序序列为：&#123;2,4,7&#125;，切割后的左子树中序序列为：&#123;4,7,2&#125;；切割后的右子树前序序列为：&#123;3,5,6,8&#125;，切割后的右子树中序序列为：&#123;5,3,8,6&#125;</span></span><br><span class="line"><span class="comment"># 对子树分别使用同样的方法分解</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reConstructBinaryTree</span>(<span class="params">pre, tin</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> pre <span class="keyword">or</span> <span class="keyword">not</span> tin:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    root = TreeNode(pre[<span class="number">0</span>])</span><br><span class="line">    index = tin.index(root.val)</span><br><span class="line">    root.left = reConstructBinaryTree(pre[<span class="number">1</span>:index+<span class="number">1</span>], tin[:index])</span><br><span class="line">    root.right = reConstructBinaryTree(pre[index+<span class="number">1</span>:], tin[index+<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h4 id="5-JZ5"><a href="#5-JZ5" class="headerlink" title="5.JZ5"></a>5.JZ5</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&amp;tqId=11157&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</span></span><br><span class="line"><span class="comment"># 描述</span></span><br><span class="line"><span class="comment"># 用两个栈来实现一个队列，分别完成在队列尾部插入整数(push)和在队列头部删除整数(pop)的功能。 队列中的元素为int类型。保证操作合法，即保证pop操作时队列内已有元素。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例:</span></span><br><span class="line"><span class="comment"># 输入:</span></span><br><span class="line"><span class="comment"># [&quot;PSH1&quot;,&quot;PSH2&quot;,&quot;POP&quot;,&quot;POP&quot;]</span></span><br><span class="line"><span class="comment"># 返回:</span></span><br><span class="line"><span class="comment"># 1,2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析:</span></span><br><span class="line"><span class="comment"># &quot;PSH1&quot;:代表将1插入队列尾部</span></span><br><span class="line"><span class="comment"># &quot;PSH2&quot;:代表将2插入队列尾部</span></span><br><span class="line"><span class="comment"># &quot;POP“:代表删除一个元素，先进先出=&gt;返回1</span></span><br><span class="line"><span class="comment"># &quot;POP“:代表删除一个元素，先进先出=&gt;返回2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例1</span></span><br><span class="line"><span class="comment"># 输入：</span></span><br><span class="line"><span class="comment"># [&quot;PSH1&quot;,&quot;PSH2&quot;,&quot;POP&quot;,&quot;POP&quot;]</span></span><br><span class="line"><span class="comment"># 返回值：</span></span><br><span class="line"><span class="comment"># 1,2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># stack1用来入队, stack2用来辅助出队，当stack2为空的时候,stack1全部pop到statck2中,stack2再pop出队列(push操作就直接往stack1中push， pop操作需要分类一下：如果stack2为空，那么需要将stack1中的数据转移到stack2中，然后在对stack2进行pop，如果stack2不为空，直接pop就ok。)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.stack1 = []</span><br><span class="line">        self.stack2 = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        self.stack1.append(node)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stack2:</span><br><span class="line">            <span class="keyword">while</span> self.stack1:</span><br><span class="line">                self.stack2.append(self.stack1.pop())</span><br><span class="line">        <span class="keyword">return</span> self.stack2.pop()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="6-JZ6"><a href="#6-JZ6" class="headerlink" title="6.JZ6"></a>6.JZ6</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&amp;tqId=11157&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</span></span><br><span class="line"><span class="comment"># # 描述</span></span><br><span class="line"><span class="comment"># # 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</span></span><br><span class="line"><span class="comment"># # 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。</span></span><br><span class="line"><span class="comment"># # NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # 示例1</span></span><br><span class="line"><span class="comment"># # 输入：</span></span><br><span class="line"><span class="comment"># # [3,4,5,1,2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # 返回值：</span></span><br><span class="line"><span class="comment"># # 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#1.被面试官锤的做法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minNumberInRotateArray1</span>(<span class="params">rotateArray</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sorted</span>(rotateArray)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.参考(https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/solution/mian-shi-ti-11-xuan-zhuan-shu-zu-de-zui-xiao-shu-3/)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minNumberInRotateArray2</span>(<span class="params">rotateArray</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> rotateArray:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(rotateArray)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid = left + (right-left)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> rotateArray[mid] &gt; rotateArray[right]:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> rotateArray[mid] &lt; rotateArray[right]:</span><br><span class="line">            right = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> rotateArray[left]</span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure><h4 id="7-JZ7"><a href="#7-JZ7" class="headerlink" title="7.JZ7"></a>7.JZ7</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=13&amp;&amp;tqId=11160&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 描述</span></span><br><span class="line"><span class="comment"># 大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。</span></span><br><span class="line"><span class="comment"># n≤39</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例1</span></span><br><span class="line"><span class="comment"># 输入：</span></span><br><span class="line"><span class="comment"># 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回值：</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.递归法(存在大量重复计算)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Fibonacci1</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">or</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> Fibonacci1(n-<span class="number">1</span>)+Fibonacci1(n-<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.迭代法(自低向上)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Fibonacci2</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">or</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    pre = <span class="number">0</span></span><br><span class="line">    after = <span class="number">1</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    i = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= n:</span><br><span class="line">        res = pre +after</span><br><span class="line">        pre = after</span><br><span class="line">        after = res</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="8-JZ8"><a href="#8-JZ8" class="headerlink" title="8.JZ8"></a>8.JZ8</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=13&amp;tqId=11160&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例1</span></span><br><span class="line"><span class="comment"># 输入：</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回值：</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例2</span></span><br><span class="line"><span class="comment"># 输入：</span></span><br><span class="line"><span class="comment"># 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回值：</span></span><br><span class="line"><span class="comment"># 21</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 和斐波那契一样的思路。注意: number=0的时候跳法是1而不是0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">jumpFloor</span>(<span class="params">number</span>):</span></span><br><span class="line">    <span class="keyword">if</span> number &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> number &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    pre = <span class="number">1</span></span><br><span class="line">    after = <span class="number">1</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    i = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= number:</span><br><span class="line">        res = pre + after</span><br><span class="line">        pre = after</span><br><span class="line">        after = res</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="9-JZ9"><a href="#9-JZ9" class="headerlink" title="9.JZ9"></a>9.JZ9</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 描述</span></span><br><span class="line"><span class="comment"># 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶(n为正整数)总共有多少种跳法。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例1</span></span><br><span class="line"><span class="comment"># 输入：</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回值：</span></span><br><span class="line"><span class="comment"># 4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.分析:</span></span><br><span class="line">    <span class="comment"># 对于方法一中的：f[n] = f[n-1] + f[n-2] + ... + f[0]</span></span><br><span class="line">    <span class="comment"># 那么f[n-1] 为多少呢？</span></span><br><span class="line">    <span class="comment"># f[n-1] = f[n-2] + f[n-3] + ... + f[0]</span></span><br><span class="line">    <span class="comment"># 所以一合并，f[n] = 2*f[n-1]，初始条件f[0] = f[1] = 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">jumpFloorII_1</span>(<span class="params">number</span>):</span></span><br><span class="line">    <span class="keyword">if</span> number &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> number == <span class="number">0</span> <span class="keyword">or</span> number == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    pre, after = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">    i = <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,number+<span class="number">1</span>):</span><br><span class="line">        after = pre * <span class="number">2</span></span><br><span class="line">        pre = after</span><br><span class="line">    <span class="keyword">return</span> after</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.由上述得出的结论又可以发现规律</span></span><br><span class="line"><span class="comment"># f[0] = f[1] = 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># f[2] = 2 = 21</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># f[3] = 4 = 22</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># f[4] = 8 = 23</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="comment"># 因此有了更简洁的解法</span></span><br><span class="line"><span class="comment"># f[n] = 2**n-1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">jumpFloorII_2</span>(<span class="params">number</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>**(number-<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="10-JZ10"><a href="#10-JZ10" class="headerlink" title="10.JZ10"></a>10.JZ10</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&amp;&amp;tqId=11163&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，</span></span><br><span class="line"><span class="comment"># 从同一个方向看总共有多少种不同的方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例1</span></span><br><span class="line"><span class="comment"># 输入：</span></span><br><span class="line"><span class="comment"># 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回值：</span></span><br><span class="line"><span class="comment"># 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例2</span></span><br><span class="line"><span class="comment"># 输入：</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回值：</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例3</span></span><br><span class="line"><span class="comment"># 输入：</span></span><br><span class="line"><span class="comment"># 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回值：</span></span><br><span class="line"><span class="comment"># 5</span></span><br><span class="line"><span class="comment"># 分析: https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&amp;&amp;tqId=11163&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</span></span><br><span class="line"><span class="comment"># 实质上也是一个斐波那契数列问题: f(n) = f(n-1) + f(n-2)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rectCover</span>(<span class="params">number</span>):</span></span><br><span class="line">    <span class="keyword">if</span> number &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> number == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> number == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    pre, after = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">    i = <span class="number">3</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= number:</span><br><span class="line">        res = pre + after</span><br><span class="line">        pre = after</span><br><span class="line">        after = res</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="11-JZ11"><a href="#11-JZ11" class="headerlink" title="11.JZ11"></a>11.JZ11</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8?tpId=13&amp;tqId=11163&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 描述</span></span><br><span class="line"><span class="comment"># 输入一个整数，输出该数32位二进制表示中1的个数。其中负数用补码表示。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例1</span></span><br><span class="line"><span class="comment"># 输入：</span></span><br><span class="line"><span class="comment"># 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回值：</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#1.直接调用库函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">NumberOf1_II</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bin</span>(n).count(<span class="string">&#x27;1&#x27;</span>) <span class="keyword">if</span> n&gt;=<span class="number">0</span> <span class="keyword">else</span> <span class="built_in">bin</span>(n+<span class="number">2</span>**<span class="number">32</span>).count(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.巧妙的思路</span></span><br><span class="line">    <span class="comment"># 把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">NumberOf1_II</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">        n = n + <span class="number">2</span>**<span class="number">32</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n:</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        n = n&amp;(n-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="12-JZ12"><a href="#12-JZ12" class="headerlink" title="12.JZ12"></a>12.JZ12</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 描述</span></span><br><span class="line"><span class="comment"># 给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保证base和exponent不同时为0。不得使用库函数，同时不需要考虑大数问题，也不用考虑小数点后面0的位数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例1</span></span><br><span class="line"><span class="comment"># 输入：</span></span><br><span class="line"><span class="comment"># 2.00000,3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回值：</span></span><br><span class="line"><span class="comment"># 8.00000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例2</span></span><br><span class="line"><span class="comment"># 输入：</span></span><br><span class="line"><span class="comment"># 2.10000,3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回值：</span></span><br><span class="line"><span class="comment"># 9.26100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例3</span></span><br><span class="line"><span class="comment"># 输入：</span></span><br><span class="line"><span class="comment"># 2.00000,-2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回值：</span></span><br><span class="line"><span class="comment"># 0.25000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：</span></span><br><span class="line"><span class="comment"># 2的-2次方等于1/4=0.25</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.直接python自带语法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Power1</span>(<span class="params">base, exponent</span>):</span></span><br><span class="line">    <span class="keyword">return</span> base**exponent</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.暴力解法，但是要考虑多种情况</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Power2</span>(<span class="params">base, exponent</span>):</span></span><br><span class="line">    res = <span class="number">1</span></span><br><span class="line">    <span class="comment">#1. 底数为0</span></span><br><span class="line">    <span class="keyword">if</span> base == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="comment">#2.指数为0</span></span><br><span class="line">    <span class="keyword">if</span> exponent == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="comment">#3.指数为负数</span></span><br><span class="line">    <span class="keyword">if</span> exponent &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(-exponent):</span><br><span class="line">            res *= base</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>/res</span><br><span class="line">    <span class="comment"># 4.指数为正数</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(exponent):</span><br><span class="line">        res *= base</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.快速幂算法(https://blog.csdn.net/hkdgjqr/article/details/5381028)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Power3</span>(<span class="params">base, exponent</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">q_power</span>(<span class="params">base, exponent</span>):</span></span><br><span class="line">        <span class="keyword">if</span> exponent == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        res = Power3(base, exponent/<span class="number">2</span>)</span><br><span class="line">        <span class="comment"># 底数为偶数</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> exponent%<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> res * res</span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># 底数为奇数</span></span><br><span class="line">            <span class="keyword">return</span> res*res*base</span><br><span class="line">    <span class="comment"># 负数特殊处理一下</span></span><br><span class="line">    <span class="keyword">if</span> exponent &lt; <span class="number">0</span>:</span><br><span class="line">        base = <span class="number">1</span>/base</span><br><span class="line">        exponent = -exponent</span><br><span class="line">    <span class="keyword">return</span> q_power(base, exponent)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">      </span><br></pre></td></tr></table></figure><h4 id="13-JZ13"><a href="#13-JZ13" class="headerlink" title="13.JZ13"></a>13.JZ13</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://www.nowcoder.com/practice/ef1f53ef31ca408cada5093c8780f44b?tpId=13&amp;&amp;tqId=11166&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 描述</span></span><br><span class="line"><span class="comment"># 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</span></span><br><span class="line"><span class="comment"># 示例1</span></span><br><span class="line"><span class="comment"># 输入：</span></span><br><span class="line"><span class="comment"># [1,2,3,4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回值：</span></span><br><span class="line"><span class="comment"># [1,3,2,4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例2</span></span><br><span class="line"><span class="comment"># 输入：</span></span><br><span class="line"><span class="comment"># [2,4,6,5,7]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回值：</span></span><br><span class="line"><span class="comment"># [5,7,2,4,6]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历一遍数组，奇数和偶数分别放两个数组，最后拼接返回去</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reOrderArray1</span>(<span class="params">array</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> array:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    n1 = []</span><br><span class="line">    n2 = []</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> array:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> num%<span class="number">2</span>:</span><br><span class="line">            n2.append(num)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            n1.append(num)</span><br><span class="line">    <span class="keyword">return</span> n1+n2</span><br><span class="line">    </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h3 id=&quot;剑指offer&quot;&gt;&lt;a href=&quot;#剑指offer&quot; class=&quot;headerlink&quot; title=&quot;剑指offer&quot;&gt;&lt;/a&gt;剑指offer&lt;/h3&gt;&lt;h4 id=&quot;1-JZ1&quot;&gt;&lt;a href=&quot;#1-JZ1&quot; class=&quot;h</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>贪心算法</title>
    <link href="http://example.com/2021/07/18/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2021/07/18/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</id>
    <published>2021-07-18T02:19:08.000Z</published>
    <updated>2021-07-18T10:57:35.509Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h4 id="findContentChildren-https-leetcode-cn-com-problems-assign-cookies"><a href="#findContentChildren-https-leetcode-cn-com-problems-assign-cookies" class="headerlink" title="findContentChildren(https://leetcode-cn.com/problems/assign-cookies/)"></a>findContentChildren(<a href="https://leetcode-cn.com/problems/assign-cookies/">https://leetcode-cn.com/problems/assign-cookies/</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://leetcode-cn.com/problems/assign-cookies/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  </span></span><br><span class="line"><span class="comment"># 示例 1:</span></span><br><span class="line"><span class="comment"># 输入: g = [1,2,3], s = [1,1]</span></span><br><span class="line"><span class="comment"># 输出: 1</span></span><br><span class="line"><span class="comment"># 解释: </span></span><br><span class="line"><span class="comment"># 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。</span></span><br><span class="line"><span class="comment"># 虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。</span></span><br><span class="line"><span class="comment"># 所以你应该输出1。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2:</span></span><br><span class="line"><span class="comment"># 输入: g = [1,2], s = [1,2,3]</span></span><br><span class="line"><span class="comment"># 输出: 2</span></span><br><span class="line"><span class="comment"># 解释: </span></span><br><span class="line"><span class="comment"># 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。</span></span><br><span class="line"><span class="comment"># 你拥有的饼干数量和尺寸都足以让所有孩子满足。</span></span><br><span class="line"><span class="comment"># 所以你应该输出2.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 贪心算法: 先排序，然后从大到小分配</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findContentChildren</span>(<span class="params">g, s</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> g <span class="keyword">or</span> <span class="keyword">not</span> s:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    g = <span class="built_in">sorted</span>(g, reverse=<span class="literal">True</span>)</span><br><span class="line">    s = <span class="built_in">sorted</span>(s, reverse=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 用两个指针来记录分配的过程</span></span><br><span class="line">    gi = <span class="number">0</span></span><br><span class="line">    si = <span class="number">0</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 贪心分配过程</span></span><br><span class="line">    <span class="keyword">while</span> gi &lt; <span class="built_in">len</span>(g) <span class="keyword">and</span> si &lt; <span class="built_in">len</span>(s):</span><br><span class="line">        <span class="keyword">if</span> g[gi] &lt;= s[si]:</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">            gi += <span class="number">1</span></span><br><span class="line">            si += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            gi +=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="isSubsequence-https-leetcode-cn-com-problems-is-subsequence"><a href="#isSubsequence-https-leetcode-cn-com-problems-is-subsequence" class="headerlink" title="isSubsequence(https://leetcode-cn.com/problems/is-subsequence/)"></a>isSubsequence(<a href="https://leetcode-cn.com/problems/is-subsequence/">https://leetcode-cn.com/problems/is-subsequence/</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://leetcode-cn.com/problems/is-subsequence/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。</span></span><br><span class="line"><span class="comment"># （例如，&quot;ace&quot;是&quot;abcde&quot;的一个子序列，而&quot;aec&quot;不是）。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进阶：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果有大量输入的 S，称作 S1, S2, ... , Sk 其中 k &gt;= 10亿，你需要依次检查它们是否为 T 的子序列。</span></span><br><span class="line"><span class="comment"># 在这种情况下，你会怎样改变代码？</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 1：</span></span><br><span class="line"><span class="comment"># 输入：s = &quot;abc&quot;, t = &quot;ahbgdc&quot;</span></span><br><span class="line"><span class="comment"># 输出：true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2：</span></span><br><span class="line"><span class="comment"># 输入：s = &quot;axc&quot;, t = &quot;ahbgdc&quot;</span></span><br><span class="line"><span class="comment"># 输出：false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 既可以叫双指针也可以叫贪心算法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isSubsequence</span>(<span class="params">s, t</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">or</span> <span class="keyword">not</span> t:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    si = <span class="number">0</span></span><br><span class="line">    ti = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> si &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> ti &lt; <span class="built_in">len</span>(t):</span><br><span class="line">        <span class="keyword">if</span> s[si] == t[ti]:</span><br><span class="line">            si += <span class="number">1</span></span><br><span class="line">            ti += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ti += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> si == <span class="built_in">len</span>(s)-<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="eraseOverlapInterval-https-leetcode-cn-com-problems-non-overlapping-intervalss"><a href="#eraseOverlapInterval-https-leetcode-cn-com-problems-non-overlapping-intervalss" class="headerlink" title="eraseOverlapInterval(https://leetcode-cn.com/problems/non-overlapping-intervalss)"></a>eraseOverlapInterval(<a href="https://leetcode-cn.com/problems/non-overlapping-intervalss">https://leetcode-cn.com/problems/non-overlapping-intervalss</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://leetcode-cn.com/problems/non-overlapping-intervals</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</span></span><br><span class="line"><span class="comment"># 注意:</span></span><br><span class="line"><span class="comment"># 可以认为区间的终点总是大于它的起点。</span></span><br><span class="line"><span class="comment"># 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。</span></span><br><span class="line"><span class="comment"># 示例 1:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入: [ [1,2], [2,3], [3,4], [1,3] ]</span></span><br><span class="line"><span class="comment"># 输出: 1</span></span><br><span class="line"><span class="comment"># 解释: 移除 [1,3] 后，剩下的区间没有重叠。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2:</span></span><br><span class="line"><span class="comment"># 输入: [ [1,2], [1,2], [1,2] ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出: 2</span></span><br><span class="line"><span class="comment"># 解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 3:</span></span><br><span class="line"><span class="comment"># 输入: [ [1,2], [2,3] ]</span></span><br><span class="line"><span class="comment"># 输出: 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 思路:该题可以用动态规划和贪心算法两种思路解决</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.动态规划算法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eraseOverlapIntervals1</span>(<span class="params">intervals</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> intervals:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 排序    </span></span><br><span class="line">    intervals.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line">    dp = [<span class="number">1</span>] * <span class="built_in">len</span>(intervals)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(intervals)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">            <span class="keyword">if</span> intervals[i][<span class="number">0</span>] &gt;= intervals[j][<span class="number">1</span>]:</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], dp[j]+<span class="number">1</span>)</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(dp)):</span><br><span class="line">        res = <span class="built_in">max</span>(res, dp[i])</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(intervals)-res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.贪心算法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eraseOverlapIntervals2</span>(<span class="params">intervals</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> intervals:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 排序</span></span><br><span class="line">    intervals.sort(key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>])</span><br><span class="line">    res = <span class="number">1</span></span><br><span class="line">    pre_i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(intervals)):</span><br><span class="line">        <span class="comment"># 如果前一个区间的end还小于后一个区间的start的话，可以加入到结果集中</span></span><br><span class="line">        <span class="keyword">if</span> intervals[i][<span class="number">0</span>] &gt; intervals[pre_i][<span class="number">1</span>]:</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">            <span class="comment"># pre_i和i 都要更新</span></span><br><span class="line">            pre_i = i</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(intervals) - res</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h4 id=&quot;findContentChildren-https-leetcode-cn-com-problems-assign-cookies&quot;&gt;&lt;a href=&quot;#findContentChildren-https-leetcode-cn-com-</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>递归与回溯</title>
    <link href="http://example.com/2021/07/12/%E9%80%92%E5%BD%92%E4%B8%8E%E5%9B%9E%E6%BA%AF/"/>
    <id>http://example.com/2021/07/12/%E9%80%92%E5%BD%92%E4%B8%8E%E5%9B%9E%E6%BA%AF/</id>
    <published>2021-07-12T00:29:23.000Z</published>
    <updated>2021-07-18T01:09:54.050Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 回溯法思路模板: backtrack的公式：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># result = []</span></span><br><span class="line"><span class="comment"># def backtrack(路径, 选择列表):</span></span><br><span class="line"><span class="comment">#     if 满足结束条件:</span></span><br><span class="line"><span class="comment">#         result.add(路径)</span></span><br><span class="line"><span class="comment">#         return</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">#     for 选择 in 选择列表:</span></span><br><span class="line"><span class="comment">#         做选择</span></span><br><span class="line"><span class="comment">#         backtrack(路径, 选择列表)</span></span><br><span class="line"><span class="comment">#         撤销选择</span></span><br></pre></td></tr></table></figure><p>[toc]</p><h4 id="permute-https-leetcode-cn-com-problems-permutations"><a href="#permute-https-leetcode-cn-com-problems-permutations" class="headerlink" title="permute(https://leetcode-cn.com/problems/permutations/)"></a>permute(<a href="https://leetcode-cn.com/problems/permutations/">https://leetcode-cn.com/problems/permutations/</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://leetcode-cn.com/problems/permutations/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 1：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入：nums = [1,2,3]</span></span><br><span class="line"><span class="comment"># 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span></span><br><span class="line"><span class="comment"># 示例 2：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入：nums = [0,1]</span></span><br><span class="line"><span class="comment"># 输出：[[0,1],[1,0]]</span></span><br><span class="line"><span class="comment"># 示例 3：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入：nums = [1]</span></span><br><span class="line"><span class="comment"># 输出：[[1]]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permute</span>(<span class="params">nums</span>):</span></span><br><span class="line">    res = []</span><br><span class="line">    path = []</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">nums</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">return</span> res.append(path[:]) <span class="comment">#注意是浅拷贝，说明找到了一组</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] <span class="keyword">in</span> path:  <span class="comment"># 说明已经收录过的元素,直接跳过</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            path.append(nums[i])</span><br><span class="line">            backtrack(nums) <span class="comment">#递归</span></span><br><span class="line">            path.pop() <span class="comment"># 回溯</span></span><br><span class="line">    backtrack(nums)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">      </span><br></pre></td></tr></table></figure><h4 id="permuteUnique-https-leetcode-cn-com-problems-permutations-ii"><a href="#permuteUnique-https-leetcode-cn-com-problems-permutations-ii" class="headerlink" title="permuteUnique(https://leetcode-cn.com/problems/permutations-ii/)"></a>permuteUnique(<a href="https://leetcode-cn.com/problems/permutations-ii/">https://leetcode-cn.com/problems/permutations-ii/</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://leetcode-cn.com/problems/permutations-ii/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 1：</span></span><br><span class="line"><span class="comment"># 输入：nums = [1,1,2]</span></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># [[1,1,2],</span></span><br><span class="line"><span class="comment">#  [1,2,1],</span></span><br><span class="line"><span class="comment">#  [2,1,1]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2：</span></span><br><span class="line"><span class="comment"># 输入：nums = [1,2,3]</span></span><br><span class="line"><span class="comment"># 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">permuteUnique</span>(<span class="params">nums</span>):</span></span><br><span class="line">    res = []</span><br><span class="line">    path = []</span><br><span class="line">    nums.sort()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trackBacking</span>():</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(nums):</span><br><span class="line">            res.append(path.copy())</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] <span class="keyword">in</span> path <span class="keyword">or</span> (i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            path.append(nums[i])</span><br><span class="line">            trackBacking(nums)</span><br><span class="line">            path.pop()</span><br><span class="line">    trackBacking(nums)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="letterCombinations-https-leetcode-cn-com-problems-letter-combinations-of-a-phone-number"><a href="#letterCombinations-https-leetcode-cn-com-problems-letter-combinations-of-a-phone-number" class="headerlink" title="letterCombinations(https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)"></a>letterCombinations(<a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 1：</span></span><br><span class="line"><span class="comment"># 输入：digits = &quot;23&quot;</span></span><br><span class="line"><span class="comment"># 输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2：</span></span><br><span class="line"><span class="comment"># 输入：digits = &quot;&quot;</span></span><br><span class="line"><span class="comment"># 输出：[]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 3：</span></span><br><span class="line"><span class="comment"># 输入：digits = &quot;2&quot;</span></span><br><span class="line"><span class="comment"># 输出：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 思路: https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/solution/tong-su-yi-dong-dong-hua-yan-shi-17-dian-hua-hao-m/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span>(<span class="params">digits</span>):</span></span><br><span class="line">    letter_maper = [</span><br><span class="line">        <span class="string">&quot;&quot;</span>, <span class="comment"># 0</span></span><br><span class="line">        <span class="string">&quot;&quot;</span>, <span class="comment"># 1</span></span><br><span class="line">        <span class="string">&quot;abc&quot;</span>, <span class="comment"># 2</span></span><br><span class="line">        <span class="string">&quot;def&quot;</span>, <span class="comment"># 3</span></span><br><span class="line">        <span class="string">&quot;ghi&quot;</span>, <span class="comment"># 4</span></span><br><span class="line">        <span class="string">&quot;jkl&quot;</span>, <span class="comment"># 5</span></span><br><span class="line">        <span class="string">&quot;mno&quot;</span>, <span class="comment"># 6</span></span><br><span class="line">        <span class="string">&quot;pqrs&quot;</span>, <span class="comment"># 7</span></span><br><span class="line">        <span class="string">&quot;tuv&quot;</span>, <span class="comment"># 8</span></span><br><span class="line">        <span class="string">&quot;wxyz&quot;</span>, <span class="comment"># 9</span></span><br><span class="line">    ]</span><br><span class="line">    res = []</span><br><span class="line">    <span class="comment"># 递归函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">s, index</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> index == <span class="built_in">len</span>(digits):</span><br><span class="line">            res.append(s)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        c = digits[index]</span><br><span class="line">        letter = letter_maper[<span class="built_in">ord</span>(c) - <span class="number">48</span>]</span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> letter:</span><br><span class="line">            dfs(s+l, index+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> digits:</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    dfs(<span class="string">&quot;&quot;</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">        </span><br></pre></td></tr></table></figure><h4 id="combine-https-leetcode-cn-com-problems-combinations"><a href="#combine-https-leetcode-cn-com-problems-combinations" class="headerlink" title="combine(https://leetcode-cn.com/problems/combinations/)"></a>combine(<a href="https://leetcode-cn.com/problems/combinations/">https://leetcode-cn.com/problems/combinations/</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://leetcode-cn.com/problems/combinations/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入: n = 4, k = 2</span></span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line"><span class="comment"># [</span></span><br><span class="line"><span class="comment">#   [2,4],</span></span><br><span class="line"><span class="comment">#   [3,4],</span></span><br><span class="line"><span class="comment">#   [2,3],</span></span><br><span class="line"><span class="comment">#   [1,2],</span></span><br><span class="line"><span class="comment">#   [1,3],</span></span><br><span class="line"><span class="comment">#   [1,4],</span></span><br><span class="line"><span class="comment"># ]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combine</span>(<span class="params">n, k</span>):</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span> <span class="keyword">or</span> n &lt; k <span class="keyword">or</span> k &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tarackbacking</span>(<span class="params">n, k , start, c</span>):</span></span><br><span class="line">        <span class="comment">#1.递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(c) == k:</span><br><span class="line">            res.append(c[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment">#2.递归过程</span></span><br><span class="line">        <span class="comment"># 这一步可以做箭枝处理</span></span><br><span class="line">        <span class="comment"># for i in range(start, n-(k-len(c))+2)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, n+<span class="number">1</span>):</span><br><span class="line">            c.append(i)</span><br><span class="line">            tarackbacking(n, k, i+<span class="number">1</span>, c)</span><br><span class="line">            c.pop()</span><br><span class="line">    c = []</span><br><span class="line">    </span><br><span class="line">    tarackbacking(n, k, <span class="number">1</span>, c)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="combinationSum-https-leetcode-cn-com-problems-combination-sum"><a href="#combinationSum-https-leetcode-cn-com-problems-combination-sum" class="headerlink" title="combinationSum(https://leetcode-cn.com/problems/combination-sum/)"></a>combinationSum(<a href="https://leetcode-cn.com/problems/combination-sum/">https://leetcode-cn.com/problems/combination-sum/</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://leetcode-cn.com/problems/combination-sum/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给定一个无重复元素的数组 candidates 和一个目标数 target ，</span></span><br><span class="line"><span class="comment"># 找出 candidates 中所有可以使数字和为 target 的组合。</span></span><br><span class="line"><span class="comment"># candidates 中的数字可以无限制重复被选取。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：</span></span><br><span class="line"><span class="comment"># 所有数字（包括 target）都是正整数。</span></span><br><span class="line"><span class="comment"># 解集不能包含重复的组合。 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 1：</span></span><br><span class="line"><span class="comment"># 输入：candidates = [2,3,6,7], target = 7,</span></span><br><span class="line"><span class="comment"># 所求解集为：</span></span><br><span class="line"><span class="comment"># [</span></span><br><span class="line"><span class="comment">#   [7],</span></span><br><span class="line"><span class="comment">#   [2,2,3]</span></span><br><span class="line"><span class="comment"># ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2：</span></span><br><span class="line"><span class="comment"># 输入：candidates = [2,3,5], target = 8,</span></span><br><span class="line"><span class="comment"># 所求解集为：</span></span><br><span class="line"><span class="comment"># [</span></span><br><span class="line"><span class="comment">#   [2,2,2,2],</span></span><br><span class="line"><span class="comment">#   [2,3,3],</span></span><br><span class="line"><span class="comment">#   [3,5]</span></span><br><span class="line"><span class="comment"># ]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span>(<span class="params">candidates, target</span>):</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> candidates:</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trackback</span>(<span class="params">candidates, start, target,c</span>):</span></span><br><span class="line">        <span class="comment">#1.递归结束条件</span></span><br><span class="line">        <span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">            res.append(c[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment">#2.递归过程</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="built_in">len</span>(candidates)):</span><br><span class="line">            <span class="comment"># 如果当前节点就不行了，就不用继续了,这里到不用继续了即包括该depth不用继续了，也包括该节点更大到child也不用继续了，该节点pop出来</span></span><br><span class="line">            <span class="keyword">if</span> target - candidates[i] &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            c.append(candidates[i])</span><br><span class="line">            trackback(candidates, i, target-candidates[i],c)</span><br><span class="line">            c.pop()</span><br><span class="line">    c = []</span><br><span class="line">    <span class="comment"># 排序是剪枝的前提</span></span><br><span class="line">    candidates.sort()</span><br><span class="line">    trackback(candidates, <span class="number">0</span>, target,c)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">l1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">l2 = l1 + [<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(l1))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(l2))</span><br><span class="line"></span><br><span class="line">l1.append(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(l1))</span><br></pre></td></tr></table></figure><h4 id="subsets-https-leetcode-cn-com-problems-subsets"><a href="#subsets-https-leetcode-cn-com-problems-subsets" class="headerlink" title="subsets(https://leetcode-cn.com/problems/subsets/)"></a>subsets(<a href="https://leetcode-cn.com/problems/subsets/">https://leetcode-cn.com/problems/subsets/</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://leetcode-cn.com/problems/subsets/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。</span></span><br><span class="line"><span class="comment"># 解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 1：</span></span><br><span class="line"><span class="comment"># 输入：nums = [1,2,3]</span></span><br><span class="line"><span class="comment"># 输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2：</span></span><br><span class="line"><span class="comment"># 输入：nums = [0]</span></span><br><span class="line"><span class="comment"># 输出：[[],[0]]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subsets</span>(<span class="params">nums</span>):</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    subset = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trackback</span>(<span class="params">nums, start, subset</span>):</span></span><br><span class="line">        <span class="comment"># 1.递归结束条件</span></span><br><span class="line">        res.append(subset[:])</span><br><span class="line">        <span class="comment">#2.递归过程 递归结束条件:当startIndex已经大于数组的长度了，就终止了，for循环本来也结束了，所以不需要终止条件</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start,<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] <span class="keyword">not</span> <span class="keyword">in</span> subset: <span class="comment"># 剪枝</span></span><br><span class="line">                subset.append(nums[i])</span><br><span class="line">            trackback(nums, i+<span class="number">1</span>, subset)</span><br><span class="line">            subset.pop()</span><br><span class="line">    trackback(nums, <span class="number">0</span> , subset)      </span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="exist-https-leetcode-cn-com-problems-word-search"><a href="#exist-https-leetcode-cn-com-problems-word-search" class="headerlink" title="exist(https://leetcode-cn.com/problems/word-search/)"></a>exist(<a href="https://leetcode-cn.com/problems/word-search/">https://leetcode-cn.com/problems/word-search/</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://leetcode-cn.com/problems/word-search/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，</span></span><br><span class="line"><span class="comment"># 返回 false 。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。</span></span><br><span class="line"><span class="comment"># 同一个单元格内的字母不允许被重复使用。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 1：</span></span><br><span class="line"><span class="comment"># 输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;</span></span><br><span class="line"><span class="comment"># 输出：true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2：</span></span><br><span class="line"><span class="comment"># 输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;SEE&quot;</span></span><br><span class="line"><span class="comment"># 输出：true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 3：</span></span><br><span class="line"><span class="comment"># 输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCB&quot;</span></span><br><span class="line"><span class="comment"># 输出：false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exist</span>(<span class="params">board, word</span>):</span></span><br><span class="line">    d = [[-<span class="number">1</span>,<span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>,<span class="number">0</span>], [<span class="number">0</span>, -<span class="number">1</span>]]</span><br><span class="line">    m = <span class="built_in">len</span>(board)</span><br><span class="line">    n = <span class="built_in">len</span>(board[<span class="number">0</span>])</span><br><span class="line">    <span class="comment"># 剪枝数组</span></span><br><span class="line">    visited = [[<span class="literal">False</span>]*n <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">    <span class="comment"># 判断坐标是否越界</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">in_area</span>(<span class="params">x, y</span>):</span></span><br><span class="line">        <span class="keyword">return</span> x&gt;=<span class="number">0</span> <span class="keyword">and</span> x &lt; m <span class="keyword">and</span> y&gt;=<span class="number">0</span> <span class="keyword">and</span> y&lt;n</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从board[startx][starty]开始。寻找word[index....word.size()]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search_word</span>(<span class="params">board, word, index, startx, starty</span>):</span></span><br><span class="line">        <span class="comment"># 递归结束条件</span></span><br><span class="line">        <span class="keyword">if</span> index == <span class="built_in">len</span>(word)-<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> board[startx][starty] == word[index]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 递归过程</span></span><br><span class="line">        <span class="keyword">if</span> board[startx][starty] == word[index]:</span><br><span class="line">            <span class="comment"># 更新剪枝标记</span></span><br><span class="line">            visited[startx][starty] = <span class="literal">True</span></span><br><span class="line">            <span class="comment"># 从startx, starty的四个方向寻找</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">                new_startx =  startx + d[i][<span class="number">0</span>]</span><br><span class="line">                new_starty = starty + d[i][<span class="number">1</span>]</span><br><span class="line">                <span class="comment"># 判断新的坐标是否越界</span></span><br><span class="line">                <span class="keyword">if</span> in_area(new_startx, new_starty) <span class="keyword">and</span> <span class="keyword">not</span> visited[new_startx][new_starty]:</span><br><span class="line">                    <span class="keyword">if</span> search_word(board, word, index+<span class="number">1</span>, new_startx, new_starty):</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="comment">#当四个方向都没有找到,回溯需要重新撤销标记</span></span><br><span class="line">            visited[startx][starty] = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> board <span class="keyword">or</span> <span class="keyword">not</span> word:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(board)):</span><br><span class="line">        <span class="keyword">for</span> j  <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(board[i])):</span><br><span class="line">            <span class="keyword">if</span> search_word(board, word, <span class="number">0</span>, i, j):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="numIslands-https-leetcode-cn-com-problems-number-of-islands"><a href="#numIslands-https-leetcode-cn-com-problems-number-of-islands" class="headerlink" title="numIslands(https://leetcode-cn.com/problems/number-of-islands/)"></a>numIslands(<a href="https://leetcode-cn.com/problems/number-of-islands/">https://leetcode-cn.com/problems/number-of-islands/</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://leetcode-cn.com/problems/number-of-islands/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给你一个由 &#x27;1&#x27;（陆地）和 &#x27;0&#x27;（水）组成的的二维网格，请你计算网格中岛屿的数量。</span></span><br><span class="line"><span class="comment"># 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</span></span><br><span class="line"><span class="comment"># 此外，你可以假设该网格的四条边均被水包围。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 1：</span></span><br><span class="line"><span class="comment"># 输入：grid = [</span></span><br><span class="line"><span class="comment">#   [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],</span></span><br><span class="line"><span class="comment">#   [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],</span></span><br><span class="line"><span class="comment">#   [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span></span><br><span class="line"><span class="comment">#   [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]</span></span><br><span class="line"><span class="comment"># ]</span></span><br><span class="line"><span class="comment"># 输出：1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入：grid = [</span></span><br><span class="line"><span class="comment">#   [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span></span><br><span class="line"><span class="comment">#   [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span></span><br><span class="line"><span class="comment">#   [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span></span><br><span class="line"><span class="comment">#   [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span></span><br><span class="line"><span class="comment"># ]</span></span><br><span class="line"><span class="comment"># 输出：3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numIslands</span>(<span class="params">grid</span>):</span></span><br><span class="line">    <span class="comment"># 用于左边向四个方向移动</span></span><br><span class="line">    d = [[-<span class="number">1</span>,<span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>,<span class="number">0</span>], [<span class="number">0</span>, -<span class="number">1</span>]]</span><br><span class="line">    m = <span class="built_in">len</span>(grid)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> m:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    n = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    <span class="comment"># 剪枝函数</span></span><br><span class="line">    vistied = [[<span class="literal">False</span>]*n <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">    <span class="comment"># 判断坐标是否越界</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">in_area</span>(<span class="params">x, y</span>):</span></span><br><span class="line">        <span class="keyword">return</span> x &gt;= <span class="number">0</span> <span class="keyword">and</span> x &lt; m <span class="keyword">and</span> y &gt;=<span class="number">0</span> <span class="keyword">and</span> y&lt; n</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 深度优先搜索:从grid[x][y]向四个方向搜索蔓延</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">grid, x, y</span>):</span></span><br><span class="line">        <span class="comment"># 后面不需要回溯重新置为False的原因是</span></span><br><span class="line">        vistied[x][y] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">            new_x = x + d[i][<span class="number">0</span>]</span><br><span class="line">            new_y = y+ d[i][<span class="number">1</span>]</span><br><span class="line">            <span class="comment"># 递归终止条件融入到这个判断语句中</span></span><br><span class="line">            <span class="keyword">if</span> in_area(new_x, new_y) <span class="keyword">and</span> grid[new_x][new_y] == <span class="string">&#x27;1&#x27;</span> <span class="keyword">and</span> <span class="keyword">not</span> vistied[new_x][new_y]:</span><br><span class="line">                dfs(grid, new_x,new_y)</span><br><span class="line">        <span class="comment"># 如果没有找到直接return</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    num_islands = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> grid[i][j] == <span class="string">&#x27;1&#x27;</span> <span class="keyword">and</span> <span class="keyword">not</span> vistied[i][j]:</span><br><span class="line">                num_islands += <span class="number">1</span></span><br><span class="line">                dfs(grid, i, j)</span><br><span class="line">    <span class="keyword">return</span> num_islands</span><br></pre></td></tr></table></figure><h4 id="solveNQueens-https-leetcode-cn-com-problems-n-queens"><a href="#solveNQueens-https-leetcode-cn-com-problems-n-queens" class="headerlink" title="solveNQueens(https://leetcode-cn.com/problems/n-queens/)"></a>solveNQueens(<a href="https://leetcode-cn.com/problems/n-queens/">https://leetcode-cn.com/problems/n-queens/</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://leetcode-cn.com/problems/n-queens/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</span></span><br><span class="line"><span class="comment"># 给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。</span></span><br><span class="line"><span class="comment"># 每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 &#x27;Q&#x27; 和 &#x27;.&#x27; 分别代表了皇后和空位。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 1：</span></span><br><span class="line"><span class="comment"># 输入：n = 4</span></span><br><span class="line"><span class="comment"># 输出：[[&quot;.Q..&quot;,&quot;...Q&quot;,&quot;Q...&quot;,&quot;..Q.&quot;],[&quot;..Q.&quot;,&quot;Q...&quot;,&quot;...Q&quot;,&quot;.Q..&quot;]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2：</span></span><br><span class="line"><span class="comment"># 输入：n = 1</span></span><br><span class="line"><span class="comment"># 输出：[[&quot;Q&quot;]]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solveNQueens</span>(<span class="params">n</span>):</span></span><br><span class="line">    res = []</span><br><span class="line">    row = []</span><br><span class="line">    <span class="comment"># 剪枝</span></span><br><span class="line">    col = [<span class="literal">False</span>]*n</span><br><span class="line">    dia1 = [<span class="literal">False</span>]*(<span class="number">2</span>*n-<span class="number">1</span>)</span><br><span class="line">    dia2 = [<span class="literal">False</span>]*(<span class="number">2</span>*n-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#组装拼接结果</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate_board</span>(<span class="params">n, row</span>):</span></span><br><span class="line">        board = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            line = [<span class="string">&#x27;.&#x27;</span>]*n</span><br><span class="line">            line[row[i]] = <span class="string">&#x27;Q&#x27;</span></span><br><span class="line">            board.append(<span class="string">&quot;&quot;</span>.join(line))</span><br><span class="line">        <span class="keyword">return</span> board</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 递归回溯过程</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put_queue</span>(<span class="params">n ,index, row</span>):</span></span><br><span class="line">        <span class="comment"># 递归结束条件</span></span><br><span class="line">        <span class="keyword">if</span> n == index:</span><br><span class="line">            res.append(generate_board(n, row[:]))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 递归过程</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># 判断当前坐标的上下以及对角线是否冲突</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> col[i] <span class="keyword">and</span> <span class="keyword">not</span> dia1[index+i] <span class="keyword">and</span> <span class="keyword">not</span> dia2[index-i+n-<span class="number">1</span>]:</span><br><span class="line">                row.append(i)</span><br><span class="line">                col[i] = <span class="literal">True</span></span><br><span class="line">                dia1[index+i] = <span class="literal">True</span></span><br><span class="line">                dia2[index-i+n-<span class="number">1</span>] = <span class="literal">True</span></span><br><span class="line">                put_queue(n, index+<span class="number">1</span>, row)</span><br><span class="line">                <span class="comment">#回溯</span></span><br><span class="line">                col[i] = <span class="literal">False</span></span><br><span class="line">                dia1[index+i] = <span class="literal">False</span></span><br><span class="line">                dia2[index-i+n-<span class="number">1</span>] = <span class="literal">False</span></span><br><span class="line">                row.pop()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    put_queue(n ,<span class="number">0</span>, row)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">           </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二叉树</title>
    <link href="http://example.com/2021/07/05/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://example.com/2021/07/05/%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2021-07-05T13:05:23.000Z</published>
    <updated>2021-07-05T15:26:33.313Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h4 id="binaryTreePaths-https-leetcode-cn-com-problems-binary-tree-paths"><a href="#binaryTreePaths-https-leetcode-cn-com-problems-binary-tree-paths" class="headerlink" title="binaryTreePaths(https://leetcode-cn.com/problems/binary-tree-paths)"></a>binaryTreePaths(<a href="https://leetcode-cn.com/problems/binary-tree-paths">https://leetcode-cn.com/problems/binary-tree-paths</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/binary-tree-paths</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给定一个二叉树，返回所有从根节点到叶子节点的路径。</span></span><br><span class="line"><span class="comment"># 说明: 叶子节点是指没有子节点的节点。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例:</span></span><br><span class="line"><span class="comment"># 输入:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#    1</span></span><br><span class="line"><span class="comment">#  /   \</span></span><br><span class="line"><span class="comment"># 2     3</span></span><br><span class="line"><span class="comment">#  \</span></span><br><span class="line"><span class="comment">#   5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]</span></span><br><span class="line"><span class="comment"># 解释: 所有根节点到叶子节点的路径为: 1-&gt;2-&gt;5, 1-&gt;3</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binaryTreePaths</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    res = []</span><br><span class="line">    <span class="comment"># 递归终止条件，但递归到该节点是叶子节点的时候，将该叶子节点的值加入到res中</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">        res.append(<span class="built_in">str</span>(root.val))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="comment"># 递归左右子树</span></span><br><span class="line">    left_path = []</span><br><span class="line">    <span class="keyword">if</span> root.left:</span><br><span class="line">        left_path = binaryTreePaths(root.left)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(left_path)):</span><br><span class="line">        res.append(<span class="built_in">str</span>(root.val) + <span class="string">&#x27;-&gt;&#x27;</span> + <span class="built_in">str</span>(left_path[i]))</span><br><span class="line"></span><br><span class="line">    right_path = []</span><br><span class="line">    <span class="keyword">if</span> root.right:</span><br><span class="line">        right_path = binaryTreePaths(root.right)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(right_path)):</span><br><span class="line">        res.append(<span class="built_in">str</span>(root.val) + <span class="string">&#x27;-&gt;&#x27;</span> + <span class="built_in">str</span>(right_path[i]))</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h4 id="hasPathSum-https-leetcode-cn-com-problems-path-sum"><a href="#hasPathSum-https-leetcode-cn-com-problems-path-sum" class="headerlink" title="hasPathSum(https://leetcode-cn.com/problems/path-sum/)"></a>hasPathSum(<a href="https://leetcode-cn.com/problems/path-sum/">https://leetcode-cn.com/problems/path-sum/</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># # https://leetcode-cn.com/problems/path-sum/</span></span><br><span class="line"><span class="comment"># 给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 叶子节点 是指没有子节点的节点。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  </span></span><br><span class="line"><span class="comment"># 示例 1：</span></span><br><span class="line"><span class="comment"># 输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22</span></span><br><span class="line"><span class="comment"># 输出：true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2：</span></span><br><span class="line"><span class="comment"># 输入：root = [1,2,3], targetSum = 5</span></span><br><span class="line"><span class="comment"># 输出：false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 3</span></span><br><span class="line"><span class="comment"># 输入：root = [1,2], targetSum = 0</span></span><br><span class="line"><span class="comment"># 输出：false</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span>(<span class="params">root, targetSum</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="comment"># 1.注意递归终止条件:判断这个节点是不是叶子节点</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">        <span class="keyword">return</span> root.val == targetSum</span><br><span class="line">    has_num = targetSum - root.val</span><br><span class="line">    <span class="comment"># 左右子树遍历是否存在路径的和</span></span><br><span class="line">    <span class="keyword">return</span> hasPathSum(root.left, has_num) <span class="keyword">or</span> hasPathSum(root.right, has_num)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="invertTree-https-leetcode-cn-com-problems-invert-binary-tree"><a href="#invertTree-https-leetcode-cn-com-problems-invert-binary-tree" class="headerlink" title="invertTree(https://leetcode-cn.com/problems/invert-binary-tree)"></a>invertTree(<a href="https://leetcode-cn.com/problems/invert-binary-tree">https://leetcode-cn.com/problems/invert-binary-tree</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://leetcode-cn.com/problems/invert-binary-tree</span></span><br><span class="line"><span class="comment"># 翻转一棵二叉树。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#      4</span></span><br><span class="line"><span class="comment">#    /   \</span></span><br><span class="line"><span class="comment">#   2     7</span></span><br><span class="line"><span class="comment">#  / \   / \</span></span><br><span class="line"><span class="comment"># 1   3 6   9</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#      4</span></span><br><span class="line"><span class="comment">#    /   \</span></span><br><span class="line"><span class="comment">#   7     2</span></span><br><span class="line"><span class="comment">#  / \   / \</span></span><br><span class="line"><span class="comment"># 9   6 3   1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">invertTree</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="comment"># 1.递归的终止条件，节点为空时返回</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    <span class="comment"># 2.交换当前节点的左右子树</span></span><br><span class="line">    root.left, root.right = root.right, root.left</span><br><span class="line">    <span class="comment"># 3.递归交换当前节点的左子树</span></span><br><span class="line">    invertTree(root.left)</span><br><span class="line">    <span class="comment"># 4.递归交换当前节点的右子树</span></span><br><span class="line">    invertTree(root.right)</span><br><span class="line">    <span class="comment"># 5.函数返回时就说明当前这个节点以及他的左右子树都已经交换完了</span></span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="isBalanced-https-leetcode-cn-com-problems-ping-heng-er-cha-shu-lcof"><a href="#isBalanced-https-leetcode-cn-com-problems-ping-heng-er-cha-shu-lcof" class="headerlink" title="isBalanced(https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/)"></a>isBalanced(<a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/">https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/</span></span><br><span class="line"><span class="comment"># 输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 1:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给定二叉树 [3,9,20,null,null,15,7]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#     3</span></span><br><span class="line"><span class="comment">#    / \</span></span><br><span class="line"><span class="comment">#   9  20</span></span><br><span class="line"><span class="comment">#     /  \</span></span><br><span class="line"><span class="comment">#    15   7</span></span><br><span class="line"><span class="comment"># 返回 true 。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给定二叉树 [1,2,2,3,3,null,null,4,4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#        1</span></span><br><span class="line"><span class="comment">#       / \</span></span><br><span class="line"><span class="comment">#      2   2</span></span><br><span class="line"><span class="comment">#     / \</span></span><br><span class="line"><span class="comment">#    3   3</span></span><br><span class="line"><span class="comment">#   / \</span></span><br><span class="line"><span class="comment">#  4   4</span></span><br><span class="line"><span class="comment"># 返回 false 。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 同样递归的思路，求</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tree_len</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">else</span> <span class="built_in">max</span>(tree_len(root.left), tree_len(root.right))+<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    left_len = tree_len(root.left)</span><br><span class="line">    right_len = tree_len(root.right)</span><br><span class="line">    <span class="comment"># 比较左右孩子的树的高度是否相差大于1</span></span><br><span class="line">    diff = left_len - right_len</span><br><span class="line">    <span class="keyword">if</span> diff &gt;<span class="number">1</span> <span class="keyword">or</span> diff &lt; -<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> isBalanced(root.left) <span class="keyword">and</span> isBalanced(root.right)</span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="isSameTree-https-leetcode-cn-com-problems-same-tree"><a href="#isSameTree-https-leetcode-cn-com-problems-same-tree" class="headerlink" title="isSameTree(https://leetcode-cn.com/problems/same-tree/)"></a>isSameTree(<a href="https://leetcode-cn.com/problems/same-tree/">https://leetcode-cn.com/problems/same-tree/</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://leetcode-cn.com/problems/same-tree/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 1：</span></span><br><span class="line"><span class="comment"># 输入：p = [1,2,3], q = [1,2,3]</span></span><br><span class="line"><span class="comment"># 输出：true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2：</span></span><br><span class="line"><span class="comment"># 输入：p = [1,2], q = [1,null,2]</span></span><br><span class="line"><span class="comment"># 输出：false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 3：</span></span><br><span class="line"><span class="comment"># 输入：p = [1,2,1], q = [1,1,2]</span></span><br><span class="line"><span class="comment"># 输出：false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 思路:递归一一对比是否相等</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span>(<span class="params">p, q</span>):</span></span><br><span class="line">    <span class="comment">#1.递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">and</span> <span class="keyword">not</span> q:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">or</span> <span class="keyword">not</span> q:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="comment"># 2.递归左右子树</span></span><br><span class="line">    <span class="keyword">if</span> p.val == q.val:</span><br><span class="line">        <span class="keyword">return</span> isSameTree(p.left, q.left) <span class="keyword">and</span> isSameTree(p.right, q.right)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="isSymmetric-https-leetcode-cn-com-problems-symmetric-tree"><a href="#isSymmetric-https-leetcode-cn-com-problems-symmetric-tree" class="headerlink" title="isSymmetric(https://leetcode-cn.com/problems/symmetric-tree/)"></a>isSymmetric(<a href="https://leetcode-cn.com/problems/symmetric-tree/">https://leetcode-cn.com/problems/symmetric-tree/</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://leetcode-cn.com/problems/symmetric-tree/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给定一个二叉树，检查它是否是镜像对称的。</span></span><br><span class="line"><span class="comment"># 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#     1</span></span><br><span class="line"><span class="comment">#    / \</span></span><br><span class="line"><span class="comment">#   2   2</span></span><br><span class="line"><span class="comment">#  / \ / \</span></span><br><span class="line"><span class="comment"># 3  4 4  3</span></span><br><span class="line"><span class="comment">#  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#     1</span></span><br><span class="line"><span class="comment">#    / \</span></span><br><span class="line"><span class="comment">#   2   2</span></span><br><span class="line"><span class="comment">#    \   \</span></span><br><span class="line"><span class="comment">#    3    3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 同样是递归思想</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> isMirror(root.left, root.right)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isMirror</span>(<span class="params">p, q</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">and</span> <span class="keyword">not</span> q:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">or</span> <span class="keyword">not</span> q:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="comment"># 因为判断是否是一个镜像，所以对比的应该是左子树的左节点和右子树的右节点以及右子树的右节点和左子树的左节点是否相等</span></span><br><span class="line">    <span class="keyword">if</span> p.val == q.val:</span><br><span class="line">        <span class="keyword">return</span> isMirror(p.left, q.right) <span class="keyword">and</span> isMirror(p.right, q.left)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="maxDepth-https-leetcode-cn-com-problems-er-cha-shu-de-shen-du-lcof"><a href="#maxDepth-https-leetcode-cn-com-problems-er-cha-shu-de-shen-du-lcof" class="headerlink" title="maxDepth(https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/)"></a>maxDepth(<a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/">https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 例如：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给定二叉树 [3,9,20,null,null,15,7]，</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#     3</span></span><br><span class="line"><span class="comment">#    / \</span></span><br><span class="line"><span class="comment">#   9  20</span></span><br><span class="line"><span class="comment">#     /  \</span></span><br><span class="line"><span class="comment">#    15   7</span></span><br><span class="line"><span class="comment"># 返回它的最大深度 3 。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 思路：用递归的思路，分别对左右孩子做递归处理，最后取大的数再加上根节点1便是最长的深度</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    left_len = maxDepth(root.left)</span><br><span class="line">    right_len = maxDepth(root.right)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(left_len, right_len)+<span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="minDepth-https-leetcode-cn-com-problems-minimum-depth-of-binary-tree"><a href="#minDepth-https-leetcode-cn-com-problems-minimum-depth-of-binary-tree" class="headerlink" title="minDepth(https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)"></a>minDepth(<a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给定一个二叉树，找出其最小深度。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：叶子节点是指没有子节点的节点。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 1：</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入：root = [3,9,20,null,null,15,7]</span></span><br><span class="line"><span class="comment"># 输出：2</span></span><br><span class="line"><span class="comment"># 示例 2：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入：root = [2,null,3,null,4,null,5,null,6]</span></span><br><span class="line"><span class="comment"># 输出：5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 思路:</span></span><br><span class="line"><span class="comment"># 思路和而二叉树的最深深度一样，换成min()即可，但是要注意一个事情，</span></span><br><span class="line"><span class="comment"># 就是但要注意如果根节点的左或右子树为空的话是构不成子树的。</span></span><br><span class="line"><span class="comment"># 而最小深度是要求从根节点到子树的。当左或右子树为空时，不符合要求。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minDepth</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 空节点不参与比较</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> root.right:</span><br><span class="line">        <span class="keyword">return</span> minDepth(root.right)+<span class="number">1</span></span><br><span class="line">    <span class="comment"># 空节点不参与比较</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root.right <span class="keyword">and</span> root.left:</span><br><span class="line">        <span class="keyword">return</span> minDepth(root.left)+<span class="number">1</span></span><br><span class="line">    <span class="comment"># 根节点的左右孩子都不为空的时候两者取小</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(minDepth(root.left), minDepth(root.right))+<span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="pathSum-https-leetcode-cn-com-problems-path-sum-ii"><a href="#pathSum-https-leetcode-cn-com-problems-path-sum-ii" class="headerlink" title="pathSum(https://leetcode-cn.com/problems/path-sum-ii/)"></a>pathSum(<a href="https://leetcode-cn.com/problems/path-sum-ii/">https://leetcode-cn.com/problems/path-sum-ii/</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://leetcode-cn.com/problems/path-sum-ii/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点路径总和等于</span></span><br><span class="line"><span class="comment"># 给定目标和的路径。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 叶子节点 是指没有子节点的节点。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 1：</span></span><br><span class="line"><span class="comment"># 输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22</span></span><br><span class="line"><span class="comment"># 输出：[[5,4,11,2],[5,8,4,5]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2：</span></span><br><span class="line"><span class="comment"># 输入：root = [1,2,3], targetSum = 5</span></span><br><span class="line"><span class="comment"># 输出：[]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 3：</span></span><br><span class="line"><span class="comment"># 输入：root = [1,2], targetSum = 0</span></span><br><span class="line"><span class="comment"># 输出：[]</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val=<span class="number">0</span>, left=<span class="literal">None</span>, right=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pathSum</span>(<span class="params">root, targetSum</span>):</span></span><br><span class="line"></span><br><span class="line">    res= []</span><br><span class="line">    path = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root, targetSum</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        path.append(root.val)</span><br><span class="line">        targetSum -= root.val</span><br><span class="line">        <span class="comment"># 递归结束条件:叶子节点并且当前节点的val == targtSum</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right <span class="keyword">and</span> targetSum == <span class="number">0</span>:</span><br><span class="line">            res.append(path[:])</span><br><span class="line">        dfs(root.left, targetSum)</span><br><span class="line">        dfs(root.right, targetSum)</span><br><span class="line">        path.pop()</span><br><span class="line">    </span><br><span class="line">    dfs(root, targetSum)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="pathSumIII-https-leetcode-cn-com-problems-path-sum-iii"><a href="#pathSumIII-https-leetcode-cn-com-problems-path-sum-iii" class="headerlink" title="pathSumIII(https://leetcode-cn.com/problems/path-sum-iii)"></a>pathSumIII(<a href="https://leetcode-cn.com/problems/path-sum-iii">https://leetcode-cn.com/problems/path-sum-iii</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># # https://leetcode-cn.com/problems/path-sum-iii/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给定一个二叉树，它的每个结点都存放着一个整数值。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 找出路径和等于给定数值的路径总数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#       10</span></span><br><span class="line"><span class="comment">#      /  \</span></span><br><span class="line"><span class="comment">#     5   -3</span></span><br><span class="line"><span class="comment">#    / \    \</span></span><br><span class="line"><span class="comment">#   3   2   11</span></span><br><span class="line"><span class="comment">#  / \   \</span></span><br><span class="line"><span class="comment"># 3  -2   1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回 3。和等于 8 的路径有:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.  5 -&gt; 3</span></span><br><span class="line"><span class="comment"># 2.  5 -&gt; 2 -&gt; 1</span></span><br><span class="line"><span class="comment"># 3.  -3 -&gt; 11</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在以node为根节点的二叉树中，寻找包含node的路经，和为sum</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findPath</span>(<span class="params">node, targetSum</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> node.val == targetSum:</span><br><span class="line">        res += <span class="number">1</span></span><br><span class="line">    res += findPath(node.left, targetSum - node.val)</span><br><span class="line">    res += findPath(node.right, targetSum - node.val)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">     </span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.在以root为根节点的二叉树中，寻找和为sum的路径，返回这样的路径个数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pathSum</span>(<span class="params">root, targetSum</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    res = findPath(root, targetSum)</span><br><span class="line">    <span class="comment">#2.不包含root且和为targetSum的路径和 </span></span><br><span class="line">    res += pathSum(root.left, targetSum)</span><br><span class="line">    res += findPath(root.right, targetSum)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="isValidBST-https-leetcode-cn-com-problems-validate-binary-search-tree-submissions"><a href="#isValidBST-https-leetcode-cn-com-problems-validate-binary-search-tree-submissions" class="headerlink" title="isValidBST(https://leetcode-cn.com/problems/validate-binary-search-tree/submissions/)"></a>isValidBST(<a href="https://leetcode-cn.com/problems/validate-binary-search-tree/submissions/">https://leetcode-cn.com/problems/validate-binary-search-tree/submissions/</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">https://leetcode-cn.com/problems/validate-binary-search-tree/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给定一个二叉树，判断其是否是一个有效的二叉搜索树。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设一个二叉搜索树具有如下特征：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 节点的左子树只包含小于当前节点的数。</span></span><br><span class="line"><span class="comment"># 节点的右子树只包含大于当前节点的数。</span></span><br><span class="line"><span class="comment"># 所有左子树和右子树自身必须也是二叉搜索树。</span></span><br><span class="line"><span class="comment"># 示例 1:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入:</span></span><br><span class="line"><span class="comment">#     2</span></span><br><span class="line"><span class="comment">#    / \</span></span><br><span class="line"><span class="comment">#   1   3</span></span><br><span class="line"><span class="comment"># 输出: true</span></span><br><span class="line"><span class="comment"># 示例 2:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入:</span></span><br><span class="line"><span class="comment">#     5</span></span><br><span class="line"><span class="comment">#    / \</span></span><br><span class="line"><span class="comment">#   1   4</span></span><br><span class="line"><span class="comment">#      / \</span></span><br><span class="line"><span class="comment">#     3   6</span></span><br><span class="line"><span class="comment"># 输出: false</span></span><br><span class="line"><span class="comment"># 解释: 输入为: [5,1,4,null,null,3,6]。</span></span><br><span class="line"><span class="comment">#      根节点的值为 5 ，但是其右子节点值为 4 。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 思路简单：将中序遍历的值一个个存入一个list中。</span></span><br><span class="line"><span class="comment"># 理解二叉搜索树后，明白二叉搜索树中序遍历后是个递增序列。最后判断list是否为一个递增序列即可</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span>(<span class="params">root</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inOrderTree</span>(<span class="params">root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        cur, res, stack = root, [], []</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                stack.append(cur)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            tmp = stack.pop()</span><br><span class="line">            res.append(tmp.val)</span><br><span class="line">            cur = tmp.right</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line">    in_oder_tree = inOrderTree(root)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(in_oder_tree)-<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> in_oder_tree[i] &gt;= in_oder_tree[i+<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h4 id=&quot;binaryTreePaths-https-leetcode-cn-com-problems-binary-tree-paths&quot;&gt;&lt;a href=&quot;#binaryTreePaths-https-leetcode-cn-com-probl</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>栈和队列</title>
    <link href="http://example.com/2021/07/05/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <id>http://example.com/2021/07/05/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</id>
    <published>2021-07-05T12:57:07.000Z</published>
    <updated>2021-07-05T13:04:49.391Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h4 id="evalRPN-https-leetcode-cn-com-problems-evaluate-reverse-polish-notation"><a href="#evalRPN-https-leetcode-cn-com-problems-evaluate-reverse-polish-notation" class="headerlink" title="evalRPN(https://leetcode-cn.com/problems/evaluate-reverse-polish-notation)"></a>evalRPN(<a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation">https://leetcode-cn.com/problems/evaluate-reverse-polish-notation</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 说明：</span></span><br><span class="line"><span class="comment"># 整数除法只保留整数部分。</span></span><br><span class="line"><span class="comment"># 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 1：</span></span><br><span class="line"><span class="comment"># 输入：tokens = [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]</span></span><br><span class="line"><span class="comment"># 输出：9</span></span><br><span class="line"><span class="comment"># 解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2：</span></span><br><span class="line"><span class="comment"># 输入：tokens = [&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;/&quot;,&quot;+&quot;]</span></span><br><span class="line"><span class="comment"># 输出：6</span></span><br><span class="line"><span class="comment"># 解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/evaluate-reverse-polish-notation</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evalRPN</span>(<span class="params">tokens</span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(tokens) &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    f1 = <span class="keyword">lambda</span> a,b:a+b</span><br><span class="line">    f2 = <span class="keyword">lambda</span> a,b:a-b</span><br><span class="line">    f3 = <span class="keyword">lambda</span> a,b:a*b</span><br><span class="line">    f4 = <span class="keyword">lambda</span> a,b:<span class="built_in">int</span>(a/<span class="built_in">float</span>(b))</span><br><span class="line">    t_map = &#123;<span class="string">&quot;+&quot;</span>: f1, <span class="string">&quot;-&quot;</span>:f2, <span class="string">&quot;*&quot;</span>:f3, <span class="string">&quot;/&quot;</span>:f4&#125;</span><br><span class="line"></span><br><span class="line">    stack= []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> tokens:</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">in</span> t_map:</span><br><span class="line">            a = stack.pop()</span><br><span class="line">            b = stack.pop()</span><br><span class="line">            stack.append(t_map[i](b,a))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            stack.append(<span class="built_in">int</span>(i))</span><br><span class="line">    <span class="keyword">return</span> stack[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">tokens = [<span class="string">&quot;10&quot;</span>,<span class="string">&quot;6&quot;</span>,<span class="string">&quot;9&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;+&quot;</span>,<span class="string">&quot;-11&quot;</span>,<span class="string">&quot;*&quot;</span>,<span class="string">&quot;/&quot;</span>,<span class="string">&quot;*&quot;</span>,<span class="string">&quot;17&quot;</span>,<span class="string">&quot;+&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;+&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> (evalRPN(tokens))</span><br></pre></td></tr></table></figure><h4 id="isValid-https-leetcode-cn-com-problems-valid-parentheses"><a href="#isValid-https-leetcode-cn-com-problems-valid-parentheses" class="headerlink" title="isValid(https://leetcode-cn.com/problems/valid-parentheses)"></a>isValid(<a href="https://leetcode-cn.com/problems/valid-parentheses">https://leetcode-cn.com/problems/valid-parentheses</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给定一个只包括 &#x27;(&#x27;，&#x27;)&#x27;，&#x27;&#123;&#x27;，&#x27;&#125;&#x27;，&#x27;[&#x27;，&#x27;]&#x27; 的字符串 s ，判断字符串是否有效。</span></span><br><span class="line"><span class="comment"># 有效字符串需满足：</span></span><br><span class="line"><span class="comment"># 左括号必须用相同类型的右括号闭合。</span></span><br><span class="line"><span class="comment"># 左括号必须以正确的顺序闭合。</span></span><br><span class="line"><span class="comment">#  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 1：</span></span><br><span class="line"><span class="comment"># 输入：s = &quot;()&quot;</span></span><br><span class="line"><span class="comment"># 输出：true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2：</span></span><br><span class="line"><span class="comment"># 输入：s = &quot;()[]&#123;&#125;&quot;</span></span><br><span class="line"><span class="comment"># 输出：true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 3：</span></span><br><span class="line"><span class="comment"># 输入：s = &quot;(]&quot;</span></span><br><span class="line"><span class="comment"># 输出：false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 4：</span></span><br><span class="line"><span class="comment"># 输入：s = &quot;([)]&quot;</span></span><br><span class="line"><span class="comment"># 输出：false</span></span><br><span class="line"><span class="comment"># 示例 5：</span></span><br><span class="line"><span class="comment"># 输入：s = &quot;&#123;[]&#125;&quot;</span></span><br><span class="line"><span class="comment"># 输出：true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/valid-parentheses</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isValid</span>(<span class="params">s</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> i == <span class="string">&#x27;(&#x27;</span> <span class="keyword">or</span> i == <span class="string">&#x27;&#123;&#x27;</span> <span class="keyword">or</span> i == <span class="string">&#x27;[&#x27;</span>:</span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(stack):</span><br><span class="line">                real_s = stack.pop()</span><br><span class="line">                match = <span class="literal">None</span></span><br><span class="line">                <span class="keyword">if</span> i == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                    match = <span class="string">&#x27;(&#x27;</span></span><br><span class="line">                <span class="keyword">elif</span> i == <span class="string">&#x27;&#125;&#x27;</span>:</span><br><span class="line">                    match = <span class="string">&#x27;&#123;&#x27;</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    match = <span class="string">&#x27;[&#x27;</span></span><br><span class="line">                <span class="keyword">if</span> real_s != match:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="comment"># 判断左右是否完全匹配</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(stack) != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = <span class="string">&#x27;]&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(isValid(s))</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure><h4 id="mergeKLists-https-leetcode-cn-com-problems-merge-k-sorted-lists"><a href="#mergeKLists-https-leetcode-cn-com-problems-merge-k-sorted-lists" class="headerlink" title="mergeKLists(https://leetcode-cn.com/problems/merge-k-sorted-lists/)"></a>mergeKLists(<a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">https://leetcode-cn.com/problems/merge-k-sorted-lists/</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://leetcode-cn.com/problems/merge-k-sorted-lists/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入：lists = [[1,4,5],[1,3,4],[2,6]]</span></span><br><span class="line"><span class="comment"># 输出：[1,1,2,3,4,4,5,6]</span></span><br><span class="line"><span class="comment"># 解释：链表数组如下：</span></span><br><span class="line"><span class="comment"># [</span></span><br><span class="line"><span class="comment">#   1-&gt;4-&gt;5,</span></span><br><span class="line"><span class="comment">#   1-&gt;3-&gt;4,</span></span><br><span class="line"><span class="comment">#   2-&gt;6</span></span><br><span class="line"><span class="comment"># ]</span></span><br><span class="line"><span class="comment"># 将它们合并到一个有序链表中得到。</span></span><br><span class="line"><span class="comment"># 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val=<span class="number">0</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.用堆排序去解决这道题</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeKLists1</span>(<span class="params">lists</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> lists:</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    <span class="keyword">import</span> heapq</span><br><span class="line">    dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">    cur = dummy</span><br><span class="line">    heap = []</span><br><span class="line">    <span class="comment"># 把所有的链表头元素遍历一遍构建成一个小顶堆</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(lists)):</span><br><span class="line">        <span class="keyword">if</span> lists[i]:</span><br><span class="line">            heapq.heappush(heap, (lists[i].val, i))</span><br><span class="line">            lists[i] = lists[i].<span class="built_in">next</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> heap:</span><br><span class="line">        val, idx = heapq.heappop(heap)</span><br><span class="line">        cur.<span class="built_in">next</span> = ListNode(val)</span><br><span class="line">        cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 每次从小顶堆里面pop出后判断该链表后面还有没有元素，有就push进</span></span><br><span class="line">        <span class="keyword">if</span> lists[idx]:</span><br><span class="line">            heapq.heappush(heap, (lists[idx].val, idx))</span><br><span class="line">            lists[idx] = lists[idx].<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.分而治之的思路,每次取中间值，然后左右递归归并，最后再归并左右两个大区间</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeTwoList</span>(<span class="params">l1, l2</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> l1:</span><br><span class="line">        <span class="keyword">return</span> l2</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> l2:</span><br><span class="line">        <span class="keyword">return</span> l1</span><br><span class="line">    pre_node = ListNode(-<span class="number">1</span>)</span><br><span class="line">    cur = pre_node</span><br><span class="line">    <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">        <span class="keyword">if</span> l1.val &lt; l2.val:</span><br><span class="line">            cur.<span class="built_in">next</span> = l1</span><br><span class="line">            l1 = l1.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur.<span class="built_in">next</span> = l2</span><br><span class="line">            l2 = l2.<span class="built_in">next</span></span><br><span class="line">        cur = cur.<span class="built_in">next</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> l1:</span><br><span class="line">        cur.<span class="built_in">next</span> = l1</span><br><span class="line">    <span class="keyword">if</span> l2:</span><br><span class="line">        cur.<span class="built_in">next</span> = l2</span><br><span class="line">    <span class="keyword">return</span> pre_node.<span class="built_in">next</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">beg, end, lists</span>):</span></span><br><span class="line">    <span class="keyword">if</span> beg == end:</span><br><span class="line">        <span class="keyword">return</span> lists[beg]</span><br><span class="line">    mid = beg + (end - beg) // <span class="number">2</span></span><br><span class="line">    sort_list1 = merge(beg, mid, lists)</span><br><span class="line">    sort_list2 = merge(mid+<span class="number">1</span>, end,lists)</span><br><span class="line">    <span class="keyword">return</span> mergeTwoList(sort_list1,sort_list2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeKLists2</span>(<span class="params">lists</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> lists:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    beg,end = <span class="number">0</span>, <span class="built_in">len</span>(lists)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> merge(beg, end , lists)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="numSquares-https-leetcode-cn-com-problems-perfect-squares"><a href="#numSquares-https-leetcode-cn-com-problems-perfect-squares" class="headerlink" title="numSquares(https://leetcode-cn.com/problems/perfect-squares/)"></a>numSquares(<a href="https://leetcode-cn.com/problems/perfect-squares/">https://leetcode-cn.com/problems/perfect-squares/</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://leetcode-cn.com/problems/perfect-squares/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># BFS 其实是很简单的基础算法，抓住如下几点即可轻松写出不易错的 baseline:</span></span><br><span class="line">    <span class="comment"># BFS 算法组成的 3 元素：队列，入队出队的节点，已访问的集合。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 队列：先入先出的容器；</span></span><br><span class="line"><span class="comment"># 节点：最好写成单独的类，比如本例写成 (value,step) 元组。也可写成 (value,visited)，看自己喜好和题目；</span></span><br><span class="line"><span class="comment"># 已访问集合：为了避免队列中插入重复的值</span></span><br><span class="line"><span class="comment"># BFS算法组成的套路：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化三元素：</span></span><br><span class="line"><span class="comment"># Node = node(n) queue = [Node] visited = set([Node.value])</span></span><br><span class="line"><span class="comment"># 操作队列 —— 弹出队首节点：</span></span><br><span class="line"><span class="comment"># vertex = queue.pop(0)</span></span><br><span class="line"><span class="comment"># 操作弹出的节点 —— 根据业务生成子节点（一个或多个）：</span></span><br><span class="line"><span class="comment"># [node(vertex.value - n*n, Node.step+1) for n in range(1,int(vertex.value**.5)+1)]</span></span><br><span class="line"><span class="comment"># 判断这些节点 —— 符合业务条件，则return，不符合业务条件，且不在已访问集合，则追加到队尾，并加入已访问集合：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># if i==0:                   </span></span><br><span class="line"><span class="comment">#     return new_vertex.step</span></span><br><span class="line">            </span><br><span class="line"><span class="comment"># elif i not in visited:</span></span><br><span class="line"><span class="comment">#     queue.append(new_vertex)</span></span><br><span class="line"><span class="comment">#     visited.add(i)```</span></span><br><span class="line"><span class="comment"># 若以上遍历完成仍未return，下面操作返回未找到代码：</span></span><br><span class="line"><span class="comment"># return -1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numSquares</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    q = deque()</span><br><span class="line">    <span class="comment"># 用来避免重复大量的元素入队 提高性能</span></span><br><span class="line">    visited = <span class="built_in">set</span>()</span><br><span class="line">    q.append((n, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        num, step = q.popleft()</span><br><span class="line">        target = [num - i*i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(num**<span class="number">0.5</span>)+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> target:</span><br><span class="line">            <span class="keyword">if</span> t == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> step+<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> t <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                q.append((t, step+<span class="number">1</span>))</span><br><span class="line">                visited.add(t)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(numSquares(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="simplifyPath-https-leetcode-cn-com-problems-simplify-path"><a href="#simplifyPath-https-leetcode-cn-com-problems-simplify-path" class="headerlink" title="simplifyPath(https://leetcode-cn.com/problems/simplify-path)"></a>simplifyPath(<a href="https://leetcode-cn.com/problems/simplify-path">https://leetcode-cn.com/problems/simplify-path</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给你一个字符串 path ，表示指向某一文件或目录的 Unix 风格 绝对路径 （以 &#x27;/&#x27; 开头），请你将其转化为更加简洁的规范路径。</span></span><br><span class="line"><span class="comment"># 在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，&#x27;//&#x27;）都被视为单个斜杠 &#x27;/&#x27; 。</span></span><br><span class="line"><span class="comment"># 对于此问题，任何其他格式的点（例如，&#x27;...&#x27;）均被视为文件/目录名称。</span></span><br><span class="line"><span class="comment"># 请注意，返回的 规范路径 必须遵循下述格式：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 始终以斜杠 &#x27;/&#x27; 开头。</span></span><br><span class="line"><span class="comment"># 两个目录名之间必须只有一个斜杠 &#x27;/&#x27; 。</span></span><br><span class="line"><span class="comment"># 最后一个目录名（如果存在）不能 以 &#x27;/&#x27; 结尾。</span></span><br><span class="line"><span class="comment"># 此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 &#x27;.&#x27; 或 &#x27;..&#x27;）。</span></span><br><span class="line"><span class="comment"># 返回简化后得到的 规范路径 。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 1：</span></span><br><span class="line"><span class="comment"># 输入：path = &quot;/home/&quot;</span></span><br><span class="line"><span class="comment"># 输出：&quot;/home&quot;</span></span><br><span class="line"><span class="comment"># 解释：注意，最后一个目录名后面没有斜杠。 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2：</span></span><br><span class="line"><span class="comment"># 输入：path = &quot;/../&quot;</span></span><br><span class="line"><span class="comment"># 输出：&quot;/&quot;</span></span><br><span class="line"><span class="comment"># 解释：从根目录向上一级是不可行的，因为根目录是你可以到达的最高级。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 3：</span></span><br><span class="line"><span class="comment"># 输入：path = &quot;/home//foo/&quot;</span></span><br><span class="line"><span class="comment"># 输出：&quot;/home/foo&quot;</span></span><br><span class="line"><span class="comment"># 解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 4：</span></span><br><span class="line"><span class="comment"># 输入：path = &quot;/a/./b/../../c/&quot;</span></span><br><span class="line"><span class="comment"># 输出：&quot;/c&quot;</span></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/simplify-path</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">simplifyPath</span>(<span class="params">path</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">len</span>(path):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    s = path.split(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">&#x27;..&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;.&#x27;</span>]:</span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">elif</span> i == <span class="string">&#x27;..&#x27;</span> <span class="keyword">and</span> stack:</span><br><span class="line">            stack.pop()</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;/&#x27;</span> + <span class="string">&#x27;/&#x27;</span>.join(stack)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(simplifyPath(<span class="string">&#x27;/home/&#x27;</span>))</span><br><span class="line"><span class="comment"># a = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br><span class="line"><span class="comment"># print(&#x27;/&#x27;.join(a))</span></span><br><span class="line"><span class="comment"># b = &#x27;/a/./b/../c&#x27;</span></span><br><span class="line"><span class="comment"># print(b.split(&#x27;/&#x27;))</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="topKFrequent-https-leetcode-cn-com-problems-top-k-frequent-elements"><a href="#topKFrequent-https-leetcode-cn-com-problems-top-k-frequent-elements" class="headerlink" title="topKFrequent(https://leetcode-cn.com/problems/top-k-frequent-elements/)"></a>topKFrequent(<a href="https://leetcode-cn.com/problems/top-k-frequent-elements/">https://leetcode-cn.com/problems/top-k-frequent-elements/</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://leetcode-cn.com/problems/top-k-frequent-elements/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">topKFrequent2</span>(<span class="params">nums, k</span>):</span></span><br><span class="line">    <span class="keyword">if</span> k &lt;= <span class="number">0</span> <span class="keyword">or</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    </span><br><span class="line">    map_count = &#123;&#125;</span><br><span class="line">    <span class="comment"># 先用字典统计一遍每个元素出现的频率</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        map_count[nums[i]] = map_count.get(nums[i], <span class="number">0</span>)+<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 构建一个固定大小为k的小顶堆</span></span><br><span class="line">    heap = []</span><br><span class="line">    <span class="keyword">for</span> num, freq <span class="keyword">in</span> map_count.items():</span><br><span class="line">        heapq.heappush(heap, (freq, num))</span><br><span class="line">        <span class="comment">#如果堆的大小大于了K，则队列弹出，保持堆的大小一直为K</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(heap) &gt; k:</span><br><span class="line">            heapq.heappop(heap)</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 返回前k的数</span></span><br><span class="line">    res=[item[<span class="number">1</span>] <span class="keyword">for</span> item <span class="keyword">in</span> heap]</span><br><span class="line">    <span class="keyword">return</span> res[::-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">topKFrequent2</span>(<span class="params">nums, k</span>):</span></span><br><span class="line">    <span class="keyword">if</span> k &lt;= <span class="number">0</span> <span class="keyword">or</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="built_in">map</span> = <span class="built_in">dict</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">map</span>:</span><br><span class="line">            <span class="built_in">map</span>[i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">map</span>[i] += <span class="number">1</span></span><br><span class="line">    r = <span class="built_in">sorted</span>(<span class="built_in">map</span>.items(), key = <span class="keyword">lambda</span> kv:(kv[<span class="number">1</span>], kv[<span class="number">0</span>]))[-k-<span class="number">1</span>:-<span class="number">1</span>]</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> k,v <span class="keyword">in</span> r:</span><br><span class="line">        res.append[k]</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">k = <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(topKFrequent(nums, k))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="orderTraversal"><a href="#orderTraversal" class="headerlink" title="orderTraversal"></a>orderTraversal</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 二叉树的遍历(四种遍历方式:前序，中序，后序，层序)</span></span><br><span class="line"><span class="comment"># https://leetcode-cn.com/problems/binary-tree-preorder-traversal/</span></span><br><span class="line"><span class="comment"># https://leetcode-cn.com/problems/binary-tree-inorder-traversal/</span></span><br><span class="line"><span class="comment"># https://leetcode-cn.com/problems/binary-tree-postorder-traversal/</span></span><br><span class="line"><span class="comment"># https://leetcode-cn.com/problems/binary-tree-level-order-traversal/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 前序遍历: 根-&gt;左-&gt;右</span></span><br><span class="line"><span class="comment"># 1.递归法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal1</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    res = []</span><br><span class="line">    res.append(root.val)</span><br><span class="line">    preorderTraversal1(root.left)</span><br><span class="line">    preorderTraversal1(root.right)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 中序遍历: 左-&gt;根-&gt;右</span></span><br><span class="line"><span class="comment"># 1.递归法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal1</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    res = []</span><br><span class="line">    preorderTraversal1(root.left)</span><br><span class="line">    res.append(root.val)</span><br><span class="line">    preorderTraversal1(root.right)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 后序遍历: 左-&gt;右-&gt;根</span></span><br><span class="line"><span class="comment"># 1.递归法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal1</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    res = []</span><br><span class="line">    preorderTraversal1(root.left)</span><br><span class="line">    preorderTraversal1(root.right)</span><br><span class="line">    res.append(root.val)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 前序遍历</span></span><br><span class="line"><span class="comment">#2.非递归法(由于栈是先入后出的特性，那么我们可以利用栈的特性模拟递归)</span></span><br><span class="line"><span class="comment"># 它先将根节点 cur 和所有的左孩子入栈并加入结果中，直至 cur 为空，</span></span><br><span class="line"><span class="comment"># 用一个 while 循环实现，然后，每弹出一个栈顶元素 tmp，就到达它的右孩子，再将这个节点当作</span></span><br><span class="line"><span class="comment"># cur 重新按上面的步骤来一遍，直至栈为空。这里又需要一个 while 循环。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal2</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    cur, res, stack = root, [], []</span><br><span class="line">    <span class="keyword">while</span> cur <span class="keyword">or</span> stack:</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            res.append(cur.val) <span class="comment"># root</span></span><br><span class="line">            stack.append(cur)</span><br><span class="line">            cur = cur.left</span><br><span class="line">        tmp = stack.pop() <span class="comment"># 每次弹出一个元素，就到达右孩子</span></span><br><span class="line">        cur = tmp.left</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 中序遍历</span></span><br><span class="line"><span class="comment"># 非递归法</span></span><br><span class="line"><span class="comment"># 和前序遍历的代码完全相同，只是在出栈的时候才将节点 tmp 的值加入到结果中。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal2</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    cur, res, stack = root, [], []</span><br><span class="line">    <span class="keyword">while</span> cur <span class="keyword">or</span> stack:</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            stack.append(cur)</span><br><span class="line">            cur = cur.left</span><br><span class="line">        tmp = stack.pop() <span class="comment"># 每次弹出一个元素，就到达右孩子</span></span><br><span class="line">        res.append(cur.val) <span class="comment">#  出栈的时候加入结果</span></span><br><span class="line">        cur = tmp.left</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 后序遍历</span></span><br><span class="line"><span class="comment"># 非递归法</span></span><br><span class="line"><span class="comment"># 继续按照上面的思想，这次我们反着思考，节点 cur 先到达最右端的叶子节点并将路径上的节点入栈；</span></span><br><span class="line"><span class="comment"># 然后每次从栈中弹出一个元素后，cur 到达它的左孩子，并将左孩子看作 cur 继续执行上面的步骤。</span></span><br><span class="line"><span class="comment"># 最后将结果反向输出即可</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal2</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    cur, res, stack = root, [], []</span><br><span class="line">    <span class="keyword">while</span> cur <span class="keyword">or</span> stack:</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            res.append(cur.val)</span><br><span class="line">            stack.append(cur)</span><br><span class="line">            cur = cur.right</span><br><span class="line">        temp = stack.pop()</span><br><span class="line">        cur= temp.left</span><br><span class="line">    <span class="keyword">return</span> res[::-<span class="number">1</span>] <span class="comment"># 反转一下</span></span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment"># 层序遍历</span></span><br><span class="line"><span class="comment"># 二叉树的层次遍历的迭代方法与前面不用，因为前面的都采用了深度优先搜索的方式，</span></span><br><span class="line"><span class="comment"># 而层次遍历使用了广度优先搜索，广度优先搜索主要使用队列实现，也就不能使用前面的模板解法了。</span></span><br><span class="line"><span class="comment"># 广度优先搜索的步骤为：(BFS)</span></span><br><span class="line"><span class="comment"># 初始化队列 q，并将根节点 root 加入到队列中；</span></span><br><span class="line"><span class="comment"># 当队列不为空时：</span></span><br><span class="line"><span class="comment">#     队列中弹出节点 node，加入到结果中；</span></span><br><span class="line"><span class="comment">#     如果左子树非空，左子树加入队列；</span></span><br><span class="line"><span class="comment">#     如果右子树非空，右子树加入队列；</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">levelorderTraversal2</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    res, q = [], [root] <span class="comment">#主队列</span></span><br><span class="line">    <span class="keyword">while</span> q:</span><br><span class="line">        q_size = <span class="built_in">len</span>(q)</span><br><span class="line">        level = []   <span class="comment">#内层队列</span></span><br><span class="line">        <span class="keyword">while</span> q_size &gt; <span class="number">0</span>:</span><br><span class="line">            node = q.pop(<span class="number">0</span>)</span><br><span class="line">            level.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                q.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                q.append(node.right)</span><br><span class="line">            q_size -= <span class="number">1</span></span><br><span class="line">        res.append(level)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h4 id=&quot;evalRPN-https-leetcode-cn-com-problems-evaluate-reverse-polish-notation&quot;&gt;&lt;a href=&quot;#evalRPN-https-leetcode-cn-com-proble</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>链表相关</title>
    <link href="http://example.com/2021/06/09/%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3/"/>
    <id>http://example.com/2021/06/09/%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3/</id>
    <published>2021-06-09T12:54:06.000Z</published>
    <updated>2021-06-20T07:25:00.664Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h4 id="reverseList-https-leetcode-cn-com-problems-fan-zhuan-lian-biao-lcof"><a href="#reverseList-https-leetcode-cn-com-problems-fan-zhuan-lian-biao-lcof" class="headerlink" title="reverseList(https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/)"></a>reverseList(<a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/">https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例:</span></span><br><span class="line"><span class="comment"># 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span></span><br><span class="line"><span class="comment"># 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.三指针思路 不断往右边滑动</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseList1</span>(<span class="params">head</span>):</span></span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    pre, curr = head, head.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">if</span> head.<span class="built_in">next</span> == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    nex = head.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">    <span class="comment"># 处理第一个元素的下个指针指向None</span></span><br><span class="line">    pre.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> nex:</span><br><span class="line">        curr.<span class="built_in">next</span> = pre</span><br><span class="line">        pre = curr</span><br><span class="line">        curr = nex</span><br><span class="line">        nex = curr.<span class="built_in">next</span></span><br><span class="line">    <span class="comment"># 处理最后一个元素</span></span><br><span class="line">    curr.<span class="built_in">next</span> = pre</span><br><span class="line">    <span class="keyword">return</span> curr</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.更简洁的写法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseList2</span>(<span class="params">head</span>):</span></span><br><span class="line">    pre = <span class="literal">None</span></span><br><span class="line">    curr = head</span><br><span class="line">    <span class="keyword">while</span> curr:</span><br><span class="line">        nex = curr.<span class="built_in">next</span></span><br><span class="line">        curr.<span class="built_in">next</span> = pre</span><br><span class="line">        pre = curr</span><br><span class="line">        curr = nex</span><br><span class="line">    <span class="keyword">return</span> pre</span><br><span class="line"></span><br><span class="line">head = ListNode(<span class="number">1</span>)</span><br><span class="line">head.<span class="built_in">next</span> = ListNode(<span class="number">2</span>)</span><br><span class="line">head.<span class="built_in">next</span>.<span class="built_in">next</span> = ListNode(<span class="number">3</span>)</span><br><span class="line">head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = ListNode(<span class="number">4</span>)</span><br><span class="line">res = reverseList1(head)</span><br><span class="line"><span class="keyword">while</span> res:</span><br><span class="line">    <span class="built_in">print</span>(res.val)</span><br><span class="line">    res = res.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="reverseBetween-https-leetcode-cn-com-problems-reverse-linked-list-ii"><a href="#reverseBetween-https-leetcode-cn-com-problems-reverse-linked-list-ii" class="headerlink" title="reverseBetween(https://leetcode-cn.com/problems/reverse-linked-list-ii)"></a>reverseBetween(<a href="https://leetcode-cn.com/problems/reverse-linked-list-ii">https://leetcode-cn.com/problems/reverse-linked-list-ii</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。</span></span><br><span class="line"><span class="comment"># 请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 1：</span></span><br><span class="line"><span class="comment"># 输入：head = [1,2,3,4,5], left = 2, right = 4</span></span><br><span class="line"><span class="comment"># 输出：[1,4,3,2,5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2：</span></span><br><span class="line"><span class="comment"># 输入：head = [5], left = 1, right = 1</span></span><br><span class="line"><span class="comment"># 输出：[5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/reverse-linked-list-ii</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span>(<span class="params">head, left, right</span>):</span></span><br><span class="line">    pre = <span class="literal">None</span></span><br><span class="line">    cur = head</span><br><span class="line">    <span class="comment"># pre指向要反转的那一段链表的前一个节点</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,left):</span><br><span class="line">        pre = cur</span><br><span class="line">        cur = cur.<span class="built_in">next</span></span><br><span class="line">    pre_temp = pre</span><br><span class="line">    cur_temp = cur</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># [left...right] 之间已经完成了链表反转 </span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(left,right+<span class="number">1</span>):</span><br><span class="line">        nex = cur.<span class="built_in">next</span> </span><br><span class="line">        cur.<span class="built_in">next</span> = pre</span><br><span class="line">        pre = cur</span><br><span class="line">        cur = nex</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 拼接左右边界的节点使得整体反转</span></span><br><span class="line">    <span class="keyword">if</span> left &gt; <span class="number">1</span>: <span class="comment"># 这种情况是为了考虑【left=1】的情况，即从头开始反转</span></span><br><span class="line">        pre_temp.<span class="built_in">next</span> = pre</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        head = pre</span><br><span class="line">    cur_temp.<span class="built_in">next</span> = cur</span><br><span class="line">    <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><h4 id="mergeTwoLists-https-leetcode-cn-com-problems-merge-two-sorted-lists"><a href="#mergeTwoLists-https-leetcode-cn-com-problems-merge-two-sorted-lists" class="headerlink" title="mergeTwoLists(https://leetcode-cn.com/problems/merge-two-sorted-lists/)"></a>mergeTwoLists(<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">https://leetcode-cn.com/problems/merge-two-sorted-lists/</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </span></span><br><span class="line"><span class="comment"># 示例 1：</span></span><br><span class="line"><span class="comment"># 输入：l1 = [1,2,4], l2 = [1,3,4]</span></span><br><span class="line"><span class="comment"># 输出：[1,1,2,3,4,4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2：</span></span><br><span class="line"><span class="comment"># 输入：l1 = [], l2 = []</span></span><br><span class="line"><span class="comment"># 输出：[]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 3：</span></span><br><span class="line"><span class="comment"># 输入：l1 = [], l2 = [0]</span></span><br><span class="line"><span class="comment"># 输出：[0]</span></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/merge-two-sorted-lists</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 双指针思路:一个指针分别指向一个链表进行遍历，每次比较把小的放到新的链表中</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val=<span class="number">0</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">l1, l2</span>):</span></span><br><span class="line">    <span class="keyword">if</span> l1 == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> l2</span><br><span class="line">    <span class="keyword">if</span> l2 == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> l1</span><br><span class="line">    newNode = ListNode(<span class="literal">None</span>)</span><br><span class="line">    res = newNode</span><br><span class="line">    <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">        <span class="keyword">if</span> l1.val &lt; l2.val:</span><br><span class="line">            res.<span class="built_in">next</span> = l1</span><br><span class="line">            l1 = l1.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res.<span class="built_in">next</span> = l2</span><br><span class="line">            l2 = l2.<span class="built_in">next</span></span><br><span class="line">        res = res.<span class="built_in">next</span></span><br><span class="line">    <span class="comment"># 当有一个链表如果没有遍历完，直接加到新的链表后即可，因为都是有序的链表</span></span><br><span class="line">    <span class="keyword">if</span>  l1:</span><br><span class="line">        res.<span class="built_in">next</span> = l1</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        res.<span class="built_in">next</span> = l2</span><br><span class="line">    <span class="keyword">return</span> newNode.<span class="built_in">next</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure><h4 id="deleteNode-https-leetcode-cn-com-problems-delete-node-in-a-linked-list"><a href="#deleteNode-https-leetcode-cn-com-problems-delete-node-in-a-linked-list" class="headerlink" title="deleteNode(https://leetcode-cn.com/problems/delete-node-in-a-linked-list)"></a>deleteNode(<a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list">https://leetcode-cn.com/problems/delete-node-in-a-linked-list</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为 要被删除的节点 。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 现有一个链表 -- head = [4,5,1,9]，它可以表示为:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 1：</span></span><br><span class="line"><span class="comment"># 输入：head = [4,5,1,9], node = 5</span></span><br><span class="line"><span class="comment"># 输出：[4,1,9]</span></span><br><span class="line"><span class="comment"># 解释：给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2：</span></span><br><span class="line"><span class="comment"># 输入：head = [4,5,1,9], node = 1</span></span><br><span class="line"><span class="comment"># 输出：[4,5,9]</span></span><br><span class="line"><span class="comment"># 解释：给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/delete-node-in-a-linked-list</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用要删除的节点的后一个节点的值覆盖掉要删除的节点的值，然后把该节点next指向next.next就好了</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span>(<span class="params">node</span>):</span></span><br><span class="line">    <span class="keyword">if</span> node == <span class="literal">None</span> <span class="keyword">or</span> node.<span class="built_in">next</span> == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    node.val = node.<span class="built_in">next</span>.val</span><br><span class="line">    node.<span class="built_in">next</span> = node.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure><h4 id="deleteDuplicates-https-leetcode-cn-com-problems-remove-duplicates-from-sorted-list"><a href="#deleteDuplicates-https-leetcode-cn-com-problems-remove-duplicates-from-sorted-list" class="headerlink" title="deleteDuplicates(https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)"></a>deleteDuplicates(<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除所有重复的元素，使每个元素 只出现一次 。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回同样按升序排列的结果链表。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  </span></span><br><span class="line"><span class="comment"># 示例 1：</span></span><br><span class="line"><span class="comment"># 输入：head = [1,1,2]</span></span><br><span class="line"><span class="comment"># 输出：[1,2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2：</span></span><br><span class="line"><span class="comment"># 输入：head = [1,1,2,3,3]</span></span><br><span class="line"><span class="comment"># 输出：[1,2,3]</span></span><br><span class="line"><span class="comment">#  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val=<span class="number">0</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.因为是顺序排好的链表，因此可以直接比较当前节点的值和下一个节点的值，如果一样就删除</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates2</span>(<span class="params">head</span>):</span></span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    </span><br><span class="line">    cur = head</span><br><span class="line">    <span class="keyword">while</span> cur.<span class="built_in">next</span>:</span><br><span class="line">        <span class="keyword">if</span> cur.val == cur.<span class="built_in">next</span>.val:</span><br><span class="line">            cur.<span class="built_in">next</span> = cur.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">head = ListNode(<span class="number">1</span>)</span><br><span class="line">head.<span class="built_in">next</span> = ListNode(<span class="number">1</span>)</span><br><span class="line">head.<span class="built_in">next</span>.<span class="built_in">next</span> = ListNode(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># head.next.next.next = ListNode(3)</span></span><br><span class="line"><span class="comment"># head.next.next.next.next = ListNode(5)</span></span><br><span class="line"></span><br><span class="line">res = deleteDuplicates2(head)</span><br><span class="line"><span class="keyword">while</span> res:</span><br><span class="line">    <span class="built_in">print</span>(res.val)</span><br><span class="line">    res = res.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><h4 id="deleteDuplicatesII-https-leetcode-cn-com-problems-remove-duplicates-from-sorted-list-ii"><a href="#deleteDuplicatesII-https-leetcode-cn-com-problems-remove-duplicates-from-sorted-list-ii" class="headerlink" title="deleteDuplicatesII(https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii)"></a>deleteDuplicatesII(<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中 没有重复出现 的数字。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回同样按升序排列的结果链表。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例一</span></span><br><span class="line"><span class="comment"># 输入：head = [1,2,3,3,4,4,5]</span></span><br><span class="line"><span class="comment"># 输出：[1,2,5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例二:</span></span><br><span class="line"><span class="comment"># 输入：head = [1,1,1,2,3]</span></span><br><span class="line"><span class="comment"># 输出：[2,3]</span></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val=<span class="number">0</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.迭代法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicatesII</span>(<span class="params">head</span>):</span></span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">    dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">    dummy.<span class="built_in">next</span> = head</span><br><span class="line">    cur = dummy</span><br><span class="line">    <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">and</span> cur.<span class="built_in">next</span>.<span class="built_in">next</span>:</span><br><span class="line">        <span class="comment"># 不相等就向下循环</span></span><br><span class="line">        <span class="keyword">if</span> cur.<span class="built_in">next</span>.val != cur.<span class="built_in">next</span>.<span class="built_in">next</span>.val:</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 相等的话就用一个变量暂时存储相等的值，每次去遍历下个节点是不是等于这个值，等于就删除，直到不相等</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            temp = cur.<span class="built_in">next</span>.val</span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">and</span> cur.<span class="built_in">next</span>.val == temp:</span><br><span class="line">                cur.<span class="built_in">next</span> = cur.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br><span class="line">         </span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.递归法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicatesII2</span>(<span class="params">head</span>):</span></span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    nex = head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> head.val == nex.val:</span><br><span class="line">        <span class="keyword">while</span> nex <span class="keyword">and</span> head.val == nex.val:</span><br><span class="line">            nex = nex.<span class="built_in">next</span></span><br><span class="line">        head = deleteDuplicatesII2(nex)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        head.<span class="built_in">next</span> = deleteDuplicatesII2(nex)</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="sort-list-https-leetcode-cn-com-problems-sort-list"><a href="#sort-list-https-leetcode-cn-com-problems-sort-list" class="headerlink" title="sort-list(https://leetcode-cn.com/problems/sort-list)"></a>sort-list(<a href="https://leetcode-cn.com/problems/sort-list">https://leetcode-cn.com/problems/sort-list</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进阶：</span></span><br><span class="line"><span class="comment"># 你可以在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序吗？</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 1:</span></span><br><span class="line"><span class="comment"># 输入：head = [4,2,1,3]</span></span><br><span class="line"><span class="comment"># 输出：[1,2,3,4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2：</span></span><br><span class="line"><span class="comment"># 输入：head = [-1,5,3,4,0]</span></span><br><span class="line"><span class="comment"># 输出：[-1,0,3,4,5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 3：</span></span><br><span class="line"><span class="comment"># 输入：head = []</span></span><br><span class="line"><span class="comment"># 输出：[]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/sort-list</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val=<span class="number">0</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回中间节点</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_mid_node</span>(<span class="params">head</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    dummy_head = ListNode(-<span class="number">1</span>)</span><br><span class="line">    dummy_head.<span class="built_in">next</span> = head</span><br><span class="line">    pre = dummy_head <span class="comment"># 设置一个虚拟头节点可以防止栈溢出</span></span><br><span class="line">    slow = head</span><br><span class="line">    fast = head</span><br><span class="line">    <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">        pre = slow</span><br><span class="line">        slow = slow.<span class="built_in">next</span></span><br><span class="line">        fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">    <span class="comment"># 前半部分链表和后半部分链表断开</span></span><br><span class="line">    pre.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> slow</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并两个有序链表</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort_list</span>(<span class="params">left, right</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> left:</span><br><span class="line">        <span class="keyword">return</span> right</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> right:</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">    res = ListNode(-<span class="number">1</span>)</span><br><span class="line">    cur = res</span><br><span class="line">    <span class="keyword">while</span> left <span class="keyword">and</span> right:</span><br><span class="line">        <span class="keyword">if</span> left.val &lt; right.val:</span><br><span class="line">            cur.<span class="built_in">next</span> = left</span><br><span class="line">            left = left.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur.<span class="built_in">next</span> = right</span><br><span class="line">            right = right.<span class="built_in">next</span></span><br><span class="line">        cur =cur.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">if</span> left:</span><br><span class="line">        cur.<span class="built_in">next</span> = left</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        cur.<span class="built_in">next</span> = right</span><br><span class="line">    <span class="keyword">return</span> res.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortList</span>(<span class="params">head</span>):</span></span><br><span class="line">    <span class="comment"># 1 递归结束条件</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 找到中间链表，并且断开链表进行递归</span></span><br><span class="line">    mid_node = get_mid_node(head)</span><br><span class="line"></span><br><span class="line">    left = sortList(head)</span><br><span class="line">    right = sortList(mid_node)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 合并两个有序链表</span></span><br><span class="line">    <span class="keyword">return</span> merge_sort_list(left, right)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="swapPairs-https-leetcode-cn-com-problems-swapping-nodes-in-a-linked-list"><a href="#swapPairs-https-leetcode-cn-com-problems-swapping-nodes-in-a-linked-list" class="headerlink" title="swapPairs(https://leetcode-cn.com/problems/swapping-nodes-in-a-linked-list/)"></a>swapPairs(<a href="https://leetcode-cn.com/problems/swapping-nodes-in-a-linked-list/">https://leetcode-cn.com/problems/swapping-nodes-in-a-linked-list/</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</span></span><br><span class="line"><span class="comment"># 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 1：</span></span><br><span class="line"><span class="comment"># 输入：head = [1,2,3,4]</span></span><br><span class="line"><span class="comment"># 输出：[2,1,4,3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2：</span></span><br><span class="line"><span class="comment"># 输入：head = []</span></span><br><span class="line"><span class="comment"># 输出：[]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 3：</span></span><br><span class="line"><span class="comment"># 输入：head = [1]</span></span><br><span class="line"><span class="comment"># 输出：[1]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置一个亚节点，并且四四指针的思路解决这道问题</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span>(<span class="params">head</span>):</span></span><br><span class="line">    dummy_head = ListNode(-<span class="number">1</span>)</span><br><span class="line">    dummy_head.<span class="built_in">next</span> = head</span><br><span class="line">    pre = dummy_head</span><br><span class="line">    <span class="keyword">while</span> pre.<span class="built_in">next</span> <span class="keyword">and</span> pre.<span class="built_in">next</span>.<span class="built_in">next</span>:</span><br><span class="line">        node1 = pre.<span class="built_in">next</span></span><br><span class="line">        node2 = node1.<span class="built_in">next</span></span><br><span class="line">        nex = node2.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 真正的反转</span></span><br><span class="line">        node2.<span class="built_in">next</span> = node1</span><br><span class="line">        node1.<span class="built_in">next</span> = nex</span><br><span class="line">        pre.<span class="built_in">next</span> = node2</span><br><span class="line">        pre = node1</span><br><span class="line">    <span class="keyword">return</span> dummy_head.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><h4 id="removeNthFromEnd-https-leetcode-cn-com-problems-remove-nth-node-from-end-of-list"><a href="#removeNthFromEnd-https-leetcode-cn-com-problems-remove-nth-node-from-end-of-list" class="headerlink" title="removeNthFromEnd(https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list)"></a>removeNthFromEnd(<a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list">https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</span></span><br><span class="line"><span class="comment"># 进阶：你能尝试使用一趟扫描实现吗？</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 1：</span></span><br><span class="line"><span class="comment"># 输入：head = [1,2,3,4,5], n = 2</span></span><br><span class="line"><span class="comment"># 输出：[1,2,3,5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2：</span></span><br><span class="line"><span class="comment"># 输入：head = [1], n = 1</span></span><br><span class="line"><span class="comment"># 输出：[]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 3：</span></span><br><span class="line"><span class="comment"># 输入：head = [1,2], n = 1</span></span><br><span class="line"><span class="comment"># 输出：[1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val=<span class="number">0</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 双指针滑动窗口思路</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span>(<span class="params">head, n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span> <span class="keyword">or</span> head == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    dummy_head = ListNode(-<span class="number">1</span>)</span><br><span class="line">    dummy_head.<span class="built_in">next</span> = head</span><br><span class="line">    slow = dummy_head</span><br><span class="line">    fast = dummy_head</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>):</span><br><span class="line">        fast = fast.<span class="built_in">next</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> slow <span class="keyword">and</span> fast:</span><br><span class="line">        slow = slow.<span class="built_in">next</span></span><br><span class="line">        fast = fast.<span class="built_in">next</span></span><br><span class="line">    </span><br><span class="line">    slow.<span class="built_in">next</span> = slow.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy_head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="removeElements-https-leetcode-cn-com-problems-remove-linked-list-elements"><a href="#removeElements-https-leetcode-cn-com-problems-remove-linked-list-elements" class="headerlink" title="removeElements(https://leetcode-cn.com/problems/remove-linked-list-elements)"></a>removeElements(<a href="https://leetcode-cn.com/problems/remove-linked-list-elements">https://leetcode-cn.com/problems/remove-linked-list-elements</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。</span></span><br><span class="line"><span class="comment">#  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 1：</span></span><br><span class="line"><span class="comment"># 输入：head = [1,2,6,3,4,5,6], val = 6</span></span><br><span class="line"><span class="comment"># 输出：[1,2,3,4,5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2：</span></span><br><span class="line"><span class="comment"># 输入：head = [], val = 1</span></span><br><span class="line"><span class="comment"># 输出：[]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 3：</span></span><br><span class="line"><span class="comment"># 输入：head = [7,7,7,7], val = 7</span></span><br><span class="line"><span class="comment"># 输出：[]</span></span><br><span class="line"><span class="comment">#  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/remove-linked-list-elements</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeElements</span>(<span class="params">head, val</span>):</span></span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    dummy_head = ListNode(-<span class="number">1</span>)</span><br><span class="line">    dummy_head.<span class="built_in">next</span> = head</span><br><span class="line">    cur = dummy_head</span><br><span class="line">    <span class="keyword">while</span> cur.<span class="built_in">next</span>:</span><br><span class="line">        <span class="keyword">if</span> cur.<span class="built_in">next</span>.val == val:</span><br><span class="line">            cur.<span class="built_in">next</span> = cur.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> dummy_head.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><h4 id="addTwoNumbers-https-leetcode-cn-com-problems-add-two-numbers"><a href="#addTwoNumbers-https-leetcode-cn-com-problems-add-two-numbers" class="headerlink" title="addTwoNumbers(https://leetcode-cn.com/problems/add-two-numbers)"></a>addTwoNumbers(<a href="https://leetcode-cn.com/problems/add-two-numbers">https://leetcode-cn.com/problems/add-two-numbers</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 请你将两个数相加，并以相同形式返回一个表示和的链表。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入：l1 = [2,4,3], l2 = [5,6,4]</span></span><br><span class="line"><span class="comment"># 输出：[7,0,8]</span></span><br><span class="line"><span class="comment"># 解释：342 + 465 = 807.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2：</span></span><br><span class="line"><span class="comment"># 输入：l1 = [0], l2 = [0]</span></span><br><span class="line"><span class="comment"># 输出：[0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 3：</span></span><br><span class="line"><span class="comment"># 输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]</span></span><br><span class="line"><span class="comment"># 输出：[8,9,9,9,0,0,0,1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/add-two-numbers</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val=<span class="number">0</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 思路:用一个变量存储每次进取的1，然后两链表的值依次相加，如果有一个先先结束，那么另外一个就继续加进取的1，直到加完，最后判断一下最后是不是还有进取的1，如果有就加到最后</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span>(<span class="params">l1, l2</span>):</span></span><br><span class="line">    dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    next1 = <span class="number">0</span></span><br><span class="line">    cur = dummy</span><br><span class="line">    <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">        total = l1.val + l2.val + next1</span><br><span class="line">        cur.<span class="built_in">next</span> = ListNode(total % <span class="number">10</span>)</span><br><span class="line">        next1 = total // <span class="number">10</span></span><br><span class="line">        cur = cur.<span class="built_in">next</span></span><br><span class="line">        l1 = l1.<span class="built_in">next</span></span><br><span class="line">        l2 = l2.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> l1:</span><br><span class="line">        total = l1.val + next1</span><br><span class="line">        cur.<span class="built_in">next</span> = ListNode(total % <span class="number">10</span>)</span><br><span class="line">        next1 = total // <span class="number">10</span></span><br><span class="line">        cur = cur.<span class="built_in">next</span></span><br><span class="line">        l1 = l1.<span class="built_in">next</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> l2:</span><br><span class="line">        total = l2.val + next1</span><br><span class="line">        cur.<span class="built_in">next</span> = ListNode(total % <span class="number">10</span>)</span><br><span class="line">        next1 = total // <span class="number">10</span></span><br><span class="line">        cur = cur.<span class="built_in">next</span></span><br><span class="line">        l2 = l2.<span class="built_in">next</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> next1 != <span class="number">0</span>:</span><br><span class="line">        cur.<span class="built_in">next</span> = ListNode(next1)</span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="reverseKGroup-https-leetcode-cn-com-problems-reverse-nodes-in-k-group"><a href="#reverseKGroup-https-leetcode-cn-com-problems-reverse-nodes-in-k-group" class="headerlink" title="reverseKGroup(https://leetcode-cn.com/problems/reverse-nodes-in-k-group)"></a>reverseKGroup(<a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group">https://leetcode-cn.com/problems/reverse-nodes-in-k-group</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># k 是一个正整数，它的值小于或等于链表的长度。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进阶：</span></span><br><span class="line"><span class="comment"># 你可以设计一个只使用常数额外空间的算法来解决此问题吗？</span></span><br><span class="line"><span class="comment"># 你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 1：</span></span><br><span class="line"><span class="comment"># 输入：head = [1,2,3,4,5], k = 2</span></span><br><span class="line"><span class="comment"># 输出：[2,1,4,3,5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2：</span></span><br><span class="line"><span class="comment"># 输入：head = [1,2,3,4,5], k = 3</span></span><br><span class="line"><span class="comment"># 输出：[3,2,1,4,5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 3：</span></span><br><span class="line"><span class="comment"># 输入：head = [1,2,3,4,5], k = 1</span></span><br><span class="line"><span class="comment"># 输出：[1,2,3,4,5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 4：</span></span><br><span class="line"><span class="comment"># 输入：head = [1], k = 1</span></span><br><span class="line"><span class="comment"># 输出：[1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/reverse-nodes-in-k-group</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val=<span class="number">0</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">head</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    <span class="comment"># dummy = ListNode(-1)</span></span><br><span class="line">    pre = <span class="literal">None</span></span><br><span class="line">    <span class="comment"># dummy.next = head</span></span><br><span class="line">    cur = head</span><br><span class="line">    nex = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        nex = cur.<span class="built_in">next</span></span><br><span class="line">        cur.<span class="built_in">next</span> = pre</span><br><span class="line">        pre = cur</span><br><span class="line">        cur = nex</span><br><span class="line">    <span class="keyword">return</span> pre</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseKGroup</span>(<span class="params">head, k</span>):</span></span><br><span class="line">    <span class="comment"># 求出链表的长度</span></span><br><span class="line">    count_head = head</span><br><span class="line">    len_list = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> count_head:</span><br><span class="line">        len_list += <span class="number">1</span></span><br><span class="line">        count_head = count_head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> k &lt;= <span class="number">0</span> <span class="keyword">or</span> k &gt; len_list <span class="keyword">or</span> head == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">    dummy.<span class="built_in">next</span> = head</span><br><span class="line">    pre = dummy</span><br><span class="line">    start = head</span><br><span class="line">    end = head</span><br><span class="line">    nex = head</span><br><span class="line">    <span class="keyword">while</span> nex:</span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; k <span class="keyword">and</span> end <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            end = end.<span class="built_in">next</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 如果链表的尾部没有被K整除，则跳出循环</span></span><br><span class="line">        <span class="keyword">if</span> end == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 反转【start...end】区间的链表</span></span><br><span class="line">        nex = end.<span class="built_in">next</span></span><br><span class="line">        end.<span class="built_in">next</span> = <span class="literal">None</span> <span class="comment"># 断开链表，翻转区间和待反转区间</span></span><br><span class="line">        end = start</span><br><span class="line">        start = reverseList(start)</span><br><span class="line">        <span class="comment"># 反转完拼接回来</span></span><br><span class="line">        end.<span class="built_in">next</span> = nex</span><br><span class="line">        pre.<span class="built_in">next</span> = start</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 重新调整pre start end nex 指针</span></span><br><span class="line">        pre = end</span><br><span class="line">        start = nex</span><br><span class="line">        end = start</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># head = ListNode(1)</span></span><br><span class="line"><span class="comment"># head.next = ListNode(2)</span></span><br><span class="line"><span class="comment"># head.next.next = ListNode(3)</span></span><br><span class="line"><span class="comment"># head.next.next.next = ListNode(4)</span></span><br><span class="line"><span class="comment"># head.next.next.next.next = ListNode(5)</span></span><br><span class="line"><span class="comment"># # head.next.next.next.next.next = ListNode(6)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># res = reverseKGroup(head, 3)</span></span><br><span class="line"><span class="comment"># while res:</span></span><br><span class="line"><span class="comment">#     print (res.val)</span></span><br><span class="line"><span class="comment">#     res = res.next</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h4 id=&quot;reverseList-https-leetcode-cn-com-problems-fan-zhuan-lian-biao-lcof&quot;&gt;&lt;a href=&quot;#reverseList-https-leetcode-cn-com-proble</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数组相关</title>
    <link href="http://example.com/2021/06/01/%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3/"/>
    <id>http://example.com/2021/06/01/%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3/</id>
    <published>2021-06-01T13:48:45.000Z</published>
    <updated>2021-07-05T12:57:14.869Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h4 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h4><h5 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_search</span>(<span class="params">array</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(array)-<span class="number">1</span>):</span><br><span class="line">        smallest_index = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, <span class="built_in">len</span>(array)):</span><br><span class="line">            <span class="keyword">if</span> array[j] &lt; array[smallest_index]:</span><br><span class="line">                smallest_index = j</span><br><span class="line">        <span class="keyword">if</span> i != smallest_index:</span><br><span class="line">            array[i],array[smallest_index] = array[smallest_index], array[i]</span><br><span class="line">    <span class="keyword">return</span> array</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">array = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(select_search(array))</span><br><span class="line">            </span><br></pre></td></tr></table></figure><h5 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_search</span>(<span class="params">array</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(array)-<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(array)-<span class="number">1</span>-i):</span><br><span class="line">            <span class="keyword">if</span> array[j] &gt; array[j+<span class="number">1</span>]:</span><br><span class="line">                array[j], array[j+<span class="number">1</span>] = array[j+<span class="number">1</span>], array[j]</span><br><span class="line">    <span class="keyword">return</span> array</span><br><span class="line"></span><br><span class="line">array = [<span class="number">1</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">10</span>]</span><br><span class="line"><span class="built_in">print</span>(bubble_search(array))</span><br></pre></td></tr></table></figure><h5 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 快速排序，分而治之+递归的思想</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span>(<span class="params">nums, left, right</span>):</span></span><br><span class="line">    <span class="keyword">if</span> left &lt; right:</span><br><span class="line">        mid = get_mid1(nums, left, right)</span><br><span class="line">        quick_sort(nums, left, mid-<span class="number">1</span>)</span><br><span class="line">        quick_sort(nums, mid+<span class="number">1</span>, right)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从小到大</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_mid</span>(<span class="params">nums,left,right</span>):</span></span><br><span class="line">    privot = nums[left]</span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[right] &gt;= privot:</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        nums[left] = nums[right]</span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left] &lt; privot:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        nums[right] = nums[left]</span><br><span class="line">    <span class="keyword">if</span> right &lt;= left:</span><br><span class="line">        nums[left] = privot</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从大到小</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_mid1</span>(<span class="params">nums,left,right</span>):</span></span><br><span class="line">    privot = nums[right]</span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left] &gt;= privot:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        nums[right] = nums[left]</span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[right] &lt; privot:</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        nums[left] = nums[right]</span><br><span class="line">    <span class="keyword">if</span> right &lt;= left:</span><br><span class="line">        nums[left] = privot</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nums = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">77</span>,<span class="number">0</span>,<span class="number">23</span>]</span><br><span class="line">quick_sort(nums,<span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(nums)</span><br></pre></td></tr></table></figure><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每次比较中间的数，若目标数大于中间数，则去右区间查找，反之去左区间查找，并且依次缩小区间，直到跳出循环</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span>(<span class="params">array, target</span>):</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = <span class="built_in">len</span>(array)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid = left + (right - left) / <span class="number">2</span> <span class="comment"># 防止整形溢出</span></span><br><span class="line">        <span class="keyword">if</span> target == array[mid]:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">if</span> target &gt; array[mid]:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid -<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="moveZero（https-leetcode-cn-com-problems-move-zeroes）"><a href="#moveZero（https-leetcode-cn-com-problems-move-zeroes）" class="headerlink" title="moveZero（https://leetcode-cn.com/problems/move-zeroes）"></a>moveZero（<a href="https://leetcode-cn.com/problems/move-zeroes%EF%BC%89">https://leetcode-cn.com/problems/move-zeroes）</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入: [0,1,0,3,12]</span></span><br><span class="line"><span class="comment"># 输出: [1,3,12,0,0]</span></span><br><span class="line"><span class="comment"># 说明:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 必须在原数组上操作，不能拷贝额外的数组。</span></span><br><span class="line"><span class="comment"># 尽量减少操作次数。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 先对整个数组进行非零扫描，然后空出来的末尾用0补充  list.remove(0)该方法没有返回值但是会移除列表中的某个值的第一个匹配项。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># def moveZeroes1(nums):</span></span><br><span class="line"><span class="comment">#     l = len(nums)</span></span><br><span class="line"><span class="comment">#     while True:</span></span><br><span class="line"><span class="comment">#         try:</span></span><br><span class="line"><span class="comment">#             nums.remove(0)</span></span><br><span class="line"><span class="comment">#         except Exception:</span></span><br><span class="line"><span class="comment">#             break</span></span><br><span class="line"><span class="comment">#     nums = nums + [0]*(l-len(nums))</span></span><br><span class="line"><span class="comment">#     return nums</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># # 双指针的方式 [0..k) 记录非0的位置</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">situation</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moveZeroes2</span>(<span class="params">self,nums</span>):</span></span><br><span class="line">        k = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i]: <span class="comment"># 记录所有非零的元素</span></span><br><span class="line">                <span class="keyword">if</span> i != k:  <span class="comment"># 考虑到数组全为0的情况</span></span><br><span class="line">                    nums[k] , nums[i] = nums[i] , nums[k]</span><br><span class="line">                    k = k + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    k = k + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="removeDuplicates-https-leetcode-cn-com-problems-remove-duplicates-from-sorted-array"><a href="#removeDuplicates-https-leetcode-cn-com-problems-remove-duplicates-from-sorted-array" class="headerlink" title="removeDuplicates(https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array)"></a>removeDuplicates(<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。</span></span><br><span class="line"><span class="comment"># 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入：nums = [1,1,2]</span></span><br><span class="line"><span class="comment"># 输出：2, nums = [1,2]</span></span><br><span class="line"><span class="comment"># 解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 双指针思路（https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/solution/shu-ju-jie-gou-he-suan-fa-shuang-zhi-zhe-12s1/）</span></span><br><span class="line"><span class="comment"># 大致就是一个前指针，一个后指针，当后指针指向的值和前置机指向的值不相等的时候，前指针向前滑动一下，并且把后指针的值赋值给前指针，最后返回前置机的位置+1便是整个数组的长度</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span>(<span class="params">nums</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[right] != nums[left]:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            nums[left] = nums[right]</span><br><span class="line">    <span class="keyword">return</span> left+<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span>(removeDuplicates(num))</span><br></pre></td></tr></table></figure><h4 id="removeElement-https-leetcode-cn-com-problems-remove-element"><a href="#removeElement-https-leetcode-cn-com-problems-remove-element" class="headerlink" title="removeElement(https://leetcode-cn.com/problems/remove-element)"></a>removeElement(<a href="https://leetcode-cn.com/problems/remove-element">https://leetcode-cn.com/problems/remove-element</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</span></span><br><span class="line"><span class="comment"># 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</span></span><br><span class="line"><span class="comment"># 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素</span></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/remove-element</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例:</span></span><br><span class="line"><span class="comment"># 输入：nums = [3,2,2,3], val = 3</span></span><br><span class="line"><span class="comment"># 输出：2, nums = [2,2]</span></span><br><span class="line"><span class="comment"># 解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 思路:双指针思路，分前后指针，前指针从零开始，后指针从末尾往前滑动，当前指针指向的数和目标数相等时，把后指针的值赋值给前指针，并且后指针--，直到条件结束</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeElement</span>(<span class="params">nums, val</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    right = <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        <span class="keyword">if</span> nums[left] == val:</span><br><span class="line">            nums[left] = nums[right]</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> nums[<span class="number">0</span>:left]</span><br><span class="line"></span><br><span class="line">nums = [<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(removeElement(nums, <span class="number">2</span>))</span><br></pre></td></tr></table></figure><h4 id="sortColors-https-leetcode-cn-com-problems-sort-colors"><a href="#sortColors-https-leetcode-cn-com-problems-sort-colors" class="headerlink" title="sortColors(https://leetcode-cn.com/problems/sort-colors)"></a>sortColors(<a href="https://leetcode-cn.com/problems/sort-colors">https://leetcode-cn.com/problems/sort-colors</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</span></span><br><span class="line"><span class="comment"># 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</span></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/sort-colors</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 1：</span></span><br><span class="line"><span class="comment"># 输入：nums = [2,0,2,1,1,0]</span></span><br><span class="line"><span class="comment"># 输出：[0,0,1,1,2,2]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 思路一:暴力排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortColors1</span>(<span class="params">nums</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">    count = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        count[nums[i]] += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(count[i]):</span><br><span class="line">            nums[index] = i</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 每次维护[0..left]都是为0，[left+1...right-1]都是为1，[right...len(nums)-1]都是2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortColors2</span>(<span class="params">nums</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    left = -<span class="number">1</span> <span class="comment">#[0...left] = 0</span></span><br><span class="line">    right = <span class="built_in">len</span>(nums) <span class="comment">#[right...len(num)-1] = 2</span></span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; right:</span><br><span class="line">        <span class="keyword">if</span> nums[i] == <span class="number">2</span>:</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">            nums[i], nums[right] = nums[right], nums[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> nums[i] == <span class="number">0</span>:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            nums[i], nums[left] = nums[left], nums[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><h4 id="mergeSortedArray-https-leetcode-cn-com-problems-merge-sorted-array"><a href="#mergeSortedArray-https-leetcode-cn-com-problems-merge-sorted-array" class="headerlink" title="mergeSortedArray(https://leetcode-cn.com/problems/merge-sorted-array/)"></a>mergeSortedArray(<a href="https://leetcode-cn.com/problems/merge-sorted-array/">https://leetcode-cn.com/problems/merge-sorted-array/</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。</span></span><br><span class="line"><span class="comment"># 初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间大小等于 m + n，这样它就有足够的空间保存来自 nums2 的元素。</span></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/merge-sorted-array</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#示例 1：</span></span><br><span class="line"><span class="comment">#输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3</span></span><br><span class="line"><span class="comment">#输出：[1,2,2,3,5,6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴力破解</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge1</span>(<span class="params">nums1, nums2</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums1) &lt;= <span class="number">0</span> <span class="keyword">or</span> <span class="built_in">len</span>(nums2) &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="comment"># 先合并再排序</span></span><br><span class="line">    nums = nums1+nums2</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sorted</span>(nums)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 双指针解法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge2</span>(<span class="params">nums1, m, nums2, n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums1) &lt;= <span class="number">0</span> <span class="keyword">or</span> <span class="built_in">len</span>(nums2)&lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    left , right, index = m-<span class="number">1</span>, n-<span class="number">1</span>, <span class="built_in">len</span>(nums1)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &gt;= <span class="number">0</span> <span class="keyword">and</span> right&gt;=<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> nums1[left] &gt;= nums2[right]:</span><br><span class="line">            nums1[index] = nums1[left]</span><br><span class="line">            left -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            nums1[index] = nums2[right]</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        index -= <span class="number">1</span></span><br><span class="line">        <span class="comment"># 如果num2还么有遍历完则继续</span></span><br><span class="line">        <span class="keyword">while</span> right &gt;= <span class="number">0</span>:</span><br><span class="line">            nums1[index] = nums2[right]</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">            index -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> nums1</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="findKthLargest-https-leetcode-cn-com-problems-kth-largest-element-in-an-array"><a href="#findKthLargest-https-leetcode-cn-com-problems-kth-largest-element-in-an-array" class="headerlink" title="findKthLargest(https://leetcode-cn.com/problems/kth-largest-element-in-an-array)"></a>findKthLargest(<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array">https://leetcode-cn.com/problems/kth-largest-element-in-an-array</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 1:</span></span><br><span class="line"><span class="comment"># 输入: [3,2,1,5,6,4] 和 k = 2</span></span><br><span class="line"><span class="comment"># 输出: 5</span></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/kth-largest-element-in-an-array</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.暴力破解</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findKthLargest1</span>(<span class="params">nums, k</span>):</span></span><br><span class="line">    <span class="keyword">if</span> k&lt;<span class="number">0</span> <span class="keyword">or</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    n = <span class="built_in">sorted</span>(nums)</span><br><span class="line">    <span class="keyword">return</span> n[-k]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.堆排序。每次维护一个K个大小的堆，每次pop堆中最小的那个数，直到最后整个堆便是前K个大的数</span></span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findKthLargest2</span>(<span class="params">nums, k</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;=<span class="number">0</span> <span class="keyword">or</span> k &lt;=<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    heap = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        heapq.heappush(heap, <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>))</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        heapq.heappush(heap, nums[k])</span><br><span class="line">        heapq.heappop(heap)</span><br><span class="line">    <span class="keyword">return</span> heap[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.快排的双指针思想</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findKthLargest3</span>(<span class="params">nums, k</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">0</span> <span class="keyword">or</span> k &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> quick_sort(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span>, k)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span>(<span class="params">nums, left, right, k</span>):</span></span><br><span class="line">    index = random_partition(nums, left, right)</span><br><span class="line">    <span class="keyword">if</span> index == k-<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nums[index]</span><br><span class="line">    <span class="keyword">elif</span> index &gt; k-<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> quick_sort(nums, left, index-<span class="number">1</span>, k)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> quick_sort(nums, index+<span class="number">1</span>, right, k)</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_partition</span>(<span class="params">nums, left, right</span>):</span></span><br><span class="line">    i = random.randint(left, right)</span><br><span class="line">    nums[i], nums[right] = nums[right], nums[i]</span><br><span class="line">    <span class="keyword">return</span> get_parition(nums, left, right)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_parition</span>(<span class="params">nums, left, right</span>):</span></span><br><span class="line">    privot = nums[right]</span><br><span class="line">    right_most = right</span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left] &gt; privot:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        nums[right] = nums[left]</span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[right] &lt;= privot:</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        nums[left] = nums[right]</span><br><span class="line">    <span class="keyword">if</span> left &gt;= right:</span><br><span class="line">        <span class="comment"># nums[left], nums[right_most]= nums[right_most], nums[left]</span></span><br><span class="line">        nums[left] = privot</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line"></span><br><span class="line">nums = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line">res = findKthLargest3(nums, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure><h4 id="two-sumi-https-leetcode-cn-com-problems-two-sum"><a href="#two-sumi-https-leetcode-cn-com-problems-two-sum" class="headerlink" title="two_sumi(https://leetcode-cn.com/problems/two-sum/)"></a>two_sumi(<a href="https://leetcode-cn.com/problems/two-sum/">https://leetcode-cn.com/problems/two-sum/</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</span></span><br><span class="line"><span class="comment"># 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</span></span><br><span class="line"><span class="comment"># 你可以按任意顺序返回答案</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 1：</span></span><br><span class="line"><span class="comment"># 输入：nums = [2,7,11,15], target = 9</span></span><br><span class="line"><span class="comment"># 输出：[0,1]</span></span><br><span class="line"><span class="comment"># 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2：</span></span><br><span class="line"><span class="comment"># 输入：nums = [3,2,4], target = 6</span></span><br><span class="line"><span class="comment"># 输出：[1,2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># https://leetcode-cn.com/problems/two-sum/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 借助散列表这种O(1时间复杂度的数据结构)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">two_sum</span>(<span class="params">nums, target</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    nums_map = <span class="built_in">dict</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        another_num = target - nums[i]</span><br><span class="line">        <span class="keyword">if</span> another_num <span class="keyword">not</span> <span class="keyword">in</span> nums_map:</span><br><span class="line">            nums_map[nums[i]] = i</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> [i, nums_map[another_num]]</span><br><span class="line">    <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure><h4 id="two-sum-ii-https-leetcode-cn-com-problems-two-sum-ii-input-array-is-sorted"><a href="#two-sum-ii-https-leetcode-cn-com-problems-two-sum-ii-input-array-is-sorted" class="headerlink" title="two_sum_ii(https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted)"></a>two_sum_ii(<a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted">https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给定一个已按照 升序排列  的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。</span></span><br><span class="line"><span class="comment"># 函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 1 开始计数 ，所以答案数组应当满足 1 &lt;= answer[0] &lt; answer[1] &lt;= numbers.length 。</span></span><br><span class="line"><span class="comment"># 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 1：</span></span><br><span class="line"><span class="comment"># 输入：numbers = [2,7,11,15], target = 9</span></span><br><span class="line"><span class="comment"># 输出：[1,2]</span></span><br><span class="line"><span class="comment"># 解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#1.暴力破解法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">two_sum1</span>(<span class="params">nums, target</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> target-nums[i] == nums[j]:</span><br><span class="line">                <span class="keyword">return</span> [i+<span class="number">1</span>, j+<span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.因为该数组是一个有序的数组，所以我们可以充分利用这一点用二分查找的思想去解决</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">two_sum2</span>(<span class="params">nums, target</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        n = target - nums[i]</span><br><span class="line">        j = binary_search(nums, n)</span><br><span class="line">        <span class="keyword">if</span> j &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> [i+<span class="number">1</span>, j+<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span>(<span class="params">nums, n</span>):</span></span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">    mid = <span class="built_in">int</span>(left + (right - left)/<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        <span class="keyword">if</span> n == nums[mid]:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> n &gt; nums[mid]:</span><br><span class="line">            left = mid +<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid -<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.双指针思想:一个从前往后滑动，一个从后往前滑动，如果两边的和大于target，右指针往前滑，反之左指针往后滑</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">two_sum3</span>(<span class="params">nums, target</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;=  <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        <span class="keyword">if</span> nums[left]+nums[right] == target:</span><br><span class="line">            <span class="keyword">return</span> [left+<span class="number">1</span>,right+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">elif</span> nums[left]+nums[right] &gt; target:</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>]</span><br><span class="line">target = <span class="number">9</span></span><br><span class="line"><span class="built_in">print</span>(two_sum3(nums, target))</span><br></pre></td></tr></table></figure><h4 id="threeSum-https-leetcode-cn-com-problems-3sum"><a href="#threeSum-https-leetcode-cn-com-problems-3sum" class="headerlink" title="threeSum(https://leetcode-cn.com/problems/3sum/)"></a>threeSum(<a href="https://leetcode-cn.com/problems/3sum/">https://leetcode-cn.com/problems/3sum/</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</span></span><br><span class="line"><span class="comment"># 注意：答案中不可以包含重复的三元组。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 1：</span></span><br><span class="line"><span class="comment"># 输入：nums = [-1,0,1,2,-1,-4]</span></span><br><span class="line"><span class="comment"># 输出：[[-1,-1,2],[-1,0,1]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2：</span></span><br><span class="line"><span class="comment"># 输入：nums = []</span></span><br><span class="line"><span class="comment"># 输出：[]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 3：</span></span><br><span class="line"><span class="comment"># 输入：nums = [0]</span></span><br><span class="line"><span class="comment"># 输出：[]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/3sum</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">three_sum</span>(<span class="params">nums</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    res = []</span><br><span class="line">    <span class="comment"># 先排序</span></span><br><span class="line">    nums = <span class="built_in">sorted</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        left, right = i+<span class="number">1</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="keyword">if</span> nums[i]+nums[left]+nums[right] == <span class="number">0</span>:</span><br><span class="line">                res.append([nums[i], nums[left], nums[right]])</span><br><span class="line">                <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left] == nums[left+<span class="number">1</span>]:  <span class="comment">#去重处理</span></span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[right] == nums[right-<span class="number">1</span>]:</span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[i]+nums[left]+nums[right] &lt; <span class="number">0</span>:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="fourSumCount-https-leetcode-cn-com-problems-4sum-ii"><a href="#fourSumCount-https-leetcode-cn-com-problems-4sum-ii" class="headerlink" title="fourSumCount(https://leetcode-cn.com/problems/4sum-ii)"></a>fourSumCount(<a href="https://leetcode-cn.com/problems/4sum-ii">https://leetcode-cn.com/problems/4sum-ii</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。</span></span><br><span class="line"><span class="comment"># 为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -228 到 228 - 1 之间，最终结果不会超过 231 - 1 。</span></span><br><span class="line"><span class="comment"># 例如:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入:</span></span><br><span class="line"><span class="comment"># A = [ 1, 2]</span></span><br><span class="line"><span class="comment"># B = [-2,-1]</span></span><br><span class="line"><span class="comment"># C = [-1, 2]</span></span><br><span class="line"><span class="comment"># D = [ 0, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解释:</span></span><br><span class="line"><span class="comment"># 两个元组如下:</span></span><br><span class="line"><span class="comment"># 1. (0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0</span></span><br><span class="line"><span class="comment"># 2. (1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/4sum-ii</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fourSumCount</span>(<span class="params">nums1, nums2, nums3, nums4</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums1) &lt;=<span class="number">0</span> <span class="keyword">or</span> <span class="built_in">len</span>(nums2)&lt;=<span class="number">0</span> <span class="keyword">or</span> <span class="built_in">len</span>(nums3)&lt;=<span class="number">0</span> <span class="keyword">or</span> <span class="built_in">len</span>(nums4)&lt;=<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 先计算nums1[i]和nums[i]的和，存进map中</span></span><br><span class="line">    num_map = &#123;&#125;</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums1)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums2)):</span><br><span class="line">            num_map[nums1[i]+nums2[j]] = num_map.get(nums1[i]+nums2[j], <span class="number">0</span>)+<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 在看nums3[i]+nums4[j]的和</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums3)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums4)):</span><br><span class="line">            s = -(nums3[i] + nums4[j])</span><br><span class="line">            <span class="keyword">if</span> s <span class="keyword">in</span> num_map:</span><br><span class="line">                res += num_map[s]</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="isPalindrome-https-leetcode-cn-com-problems-valid-palindrome"><a href="#isPalindrome-https-leetcode-cn-com-problems-valid-palindrome" class="headerlink" title="isPalindrome(https://leetcode-cn.com/problems/valid-palindrome/)"></a>isPalindrome(<a href="https://leetcode-cn.com/problems/valid-palindrome/">https://leetcode-cn.com/problems/valid-palindrome/</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</span></span><br><span class="line"><span class="comment"># 说明：本题中，我们将空字符串定义为有效的回文串。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 1:</span></span><br><span class="line"><span class="comment"># 输入: &quot;A man, a plan, a canal: Panama&quot;</span></span><br><span class="line"><span class="comment"># 输出: true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2:</span></span><br><span class="line"><span class="comment"># 输入: &quot;race a car&quot;</span></span><br><span class="line"><span class="comment"># 输出: false</span></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/valid-palindrome</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">s</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    s1 = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        <span class="keyword">if</span> ((s[i] &gt;= <span class="string">&#x27;a&#x27;</span> <span class="keyword">and</span> s[i] &lt;=<span class="string">&#x27;z&#x27;</span>) <span class="keyword">or</span> (s[i] &gt;=<span class="string">&#x27;A&#x27;</span> <span class="keyword">and</span> s[i] &lt;= <span class="string">&#x27;Z&#x27;</span>) <span class="keyword">or</span> (s[i] &gt;= <span class="string">&#x27;0&#x27;</span> <span class="keyword">and</span> s[i] &lt;=<span class="string">&#x27;9&#x27;</span>)):</span><br><span class="line">            s1.append(s[i])</span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(s1)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s1) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        <span class="keyword">if</span> s1[left].lower() == s1[right].lower():</span><br><span class="line">            <span class="comment"># return isPalindrome(s[left+1:right-1])</span></span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">s = <span class="string">&quot;ab_a&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">0</span>] == s[<span class="built_in">len</span>(s) -<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(isPalindrome(s))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="maxArea-https-leetcode-cn-com-problems-container-with-most-water"><a href="#maxArea-https-leetcode-cn-com-problems-container-with-most-water" class="headerlink" title="maxArea(https://leetcode-cn.com/problems/container-with-most-water)"></a>maxArea(<a href="https://leetcode-cn.com/problems/container-with-most-water">https://leetcode-cn.com/problems/container-with-most-water</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。</span></span><br><span class="line"><span class="comment"># 在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。</span></span><br><span class="line"><span class="comment"># 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</span></span><br><span class="line"><span class="comment"># 说明：你不能倾斜容器。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/container-with-most-water</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 面积取决于短板。</span></span><br><span class="line"><span class="comment"># 1.因此即使长板往内移动时遇到更长的板，矩形的面积也不会改变；遇到更短的板时，面积会变小。</span></span><br><span class="line"><span class="comment"># 2.因此想要面积变大，只能让短板往内移动(因为移动方向固定了)，当然也有可能让面积变得更小，但只有这样才存在让面积变大的可能性</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 因此双指针的思路解决这道题目:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxArea1</span>(<span class="params">height</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(height) &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    maxV = -<span class="number">1</span></span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(height)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        <span class="keyword">if</span> height[left] &lt; height[right]:</span><br><span class="line">            maxV = <span class="built_in">max</span>(maxV, height[left]*(right-left))</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            maxV = <span class="built_in">max</span>(maxV, height[right]*(right-left))</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> maxV</span><br><span class="line"></span><br><span class="line">height = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">18</span>,<span class="number">17</span>,<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">res = maxArea1(height)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="minSubArrayLen-https-leetcode-cn-com-problems-minimum-size-subarray-sum"><a href="#minSubArrayLen-https-leetcode-cn-com-problems-minimum-size-subarray-sum" class="headerlink" title="minSubArrayLen(https://leetcode-cn.com/problems/minimum-size-subarray-sum)"></a>minSubArrayLen(<a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum">https://leetcode-cn.com/problems/minimum-size-subarray-sum</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给定一个含有 n 个正整数的数组和一个正整数 target 。</span></span><br><span class="line"><span class="comment"># 找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 1：</span></span><br><span class="line"><span class="comment"># 输入：target = 7, nums = [2,3,1,2,4,3]</span></span><br><span class="line"><span class="comment"># 输出：2</span></span><br><span class="line"><span class="comment"># 解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2：</span></span><br><span class="line"><span class="comment"># 输入：target = 4, nums = [1,4,4]</span></span><br><span class="line"><span class="comment"># 输出：1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/minimum-size-subarray-sum</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.暴力破解法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minSubArrayLen1</span>(<span class="params">s, nums</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    minlen = <span class="built_in">len</span>(nums)+<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="built_in">sum</span> += nums[j]</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span> &gt;= s:</span><br><span class="line">                minlen = <span class="built_in">min</span>(minlen, j-i+<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> minlen == <span class="built_in">len</span>(nums)+<span class="number">1</span> <span class="keyword">else</span> minlen</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.双指针算法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minSubArrayLen2</span>(<span class="params">s, nums</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    left, right = <span class="number">0</span> , -<span class="number">1</span></span><br><span class="line">    min_len = <span class="built_in">len</span>(nums)+<span class="number">1</span></span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sum</span> &lt; s) <span class="keyword">and</span> (right &lt; <span class="built_in">len</span>(nums)-<span class="number">1</span>): <span class="comment"># 小了的话就把这个窗口往右滑动</span></span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">            <span class="built_in">sum</span> += nums[right]</span><br><span class="line">        <span class="keyword">else</span>:                                  <span class="comment"># 大了就把这个窗口往左边滑动</span></span><br><span class="line">            <span class="built_in">sum</span> -= nums[left]</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">sum</span> &gt;= s:</span><br><span class="line">            min_len = <span class="built_in">min</span>(min_len, right-left+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> min_len==<span class="built_in">len</span>(nums)+<span class="number">1</span> <span class="keyword">else</span> min_len</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br><span class="line">target = <span class="number">7</span></span><br><span class="line"><span class="built_in">print</span>(minSubArrayLen2(target, nums))                </span><br></pre></td></tr></table></figure><h4 id="lengthOfLongestSubstring-https-leetcode-cn-com-problems-zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof"><a href="#lengthOfLongestSubstring-https-leetcode-cn-com-problems-zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof" class="headerlink" title="lengthOfLongestSubstring(https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/)"></a>lengthOfLongestSubstring(<a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</span></span><br><span class="line"><span class="comment"># 示例 1:</span></span><br><span class="line"><span class="comment"># 输入: s = &quot;abcabcbb&quot;</span></span><br><span class="line"><span class="comment"># 输出: 3 </span></span><br><span class="line"><span class="comment"># 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2:</span></span><br><span class="line"><span class="comment"># 输入: s = &quot;bbbbb&quot;</span></span><br><span class="line"><span class="comment"># 输出: 1</span></span><br><span class="line"><span class="comment"># 解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 滑动窗口的思想,并且用一个一维数组储存每个字母对应的ascill码出现的频率                      </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">s</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    left, right = <span class="number">0</span>, -<span class="number">1</span> <span class="comment">#[left...right]区间的滑动窗口</span></span><br><span class="line">    max_len = <span class="number">0</span></span><br><span class="line">    freq = [<span class="number">0</span>]*<span class="number">256</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; <span class="built_in">len</span>(s):</span><br><span class="line">        <span class="keyword">if</span> right+<span class="number">1</span> &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> freq[<span class="built_in">ord</span>(s[right+<span class="number">1</span>])] == <span class="number">0</span>:</span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">            freq[<span class="built_in">ord</span>(s[right])] += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            freq[<span class="built_in">ord</span>(s[left])] -= <span class="number">1</span></span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        max_len = <span class="built_in">max</span>(max_len, right-left+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> max_len </span><br><span class="line"></span><br><span class="line">s = <span class="string">&quot;pwwkew&quot;</span></span><br><span class="line"><span class="built_in">print</span>(lengthOfLongestSubstring(s))</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="isHappy-https-leetcode-cn-com-problems-happy-number"><a href="#isHappy-https-leetcode-cn-com-problems-happy-number" class="headerlink" title="isHappy(https://leetcode-cn.com/problems/happy-number)"></a>isHappy(<a href="https://leetcode-cn.com/problems/happy-number">https://leetcode-cn.com/problems/happy-number</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编写一个算法来判断一个数 n 是不是快乐数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 「快乐数」定义为：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</span></span><br><span class="line"><span class="comment"># 然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。</span></span><br><span class="line"><span class="comment"># 如果 可以变为  1，那么这个数就是快乐数。</span></span><br><span class="line"><span class="comment"># 如果 n 是快乐数就返回 true ；不是，则返回 false 。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 1：</span></span><br><span class="line"><span class="comment"># 输入：19</span></span><br><span class="line"><span class="comment"># 输出：true</span></span><br><span class="line"><span class="comment"># 解释：</span></span><br><span class="line"><span class="comment"># 12 + 92 = 82</span></span><br><span class="line"><span class="comment"># 82 + 22 = 68</span></span><br><span class="line"><span class="comment"># 62 + 82 = 100</span></span><br><span class="line"><span class="comment"># 12 + 02 + 02 = 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2：</span></span><br><span class="line"><span class="comment"># 输入：n = 2</span></span><br><span class="line"><span class="comment"># 输出：false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/happy-number</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.快慢双指针，快的走两步，慢的走一步，如果是一个快乐数，那么快的指针肯定要比慢的指针先到达1，若不是一个快乐数，则慢的指针</span></span><br><span class="line"><span class="comment"># 一定会在某个节点追上快指针</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_square_num</span>(<span class="params">n</span>):</span></span><br><span class="line">    square_sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        square_sum  += (n%<span class="number">10</span>)*(n%<span class="number">10</span>)</span><br><span class="line">        n = n//<span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> square_sum</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isHappy1</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    slow, fast = n, get_square_num(n)</span><br><span class="line">    <span class="keyword">while</span> fast != slow <span class="keyword">and</span> fast!= <span class="number">1</span>:</span><br><span class="line">        slow = get_square_num(slow)</span><br><span class="line">        fast = get_square_num(fast)</span><br><span class="line">        fast = get_square_num(fast)</span><br><span class="line">    <span class="keyword">return</span> fast == <span class="number">1</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.用集合的思路:把每次计算出来的平方和放到一个set集合中，每次把计算值的放进set集合中，每次计算完再去判断是不是已经计算过</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isHappy2</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    s = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">while</span> n != <span class="number">1</span> <span class="keyword">and</span> n <span class="keyword">not</span> <span class="keyword">in</span> s:</span><br><span class="line">        s.add(n)</span><br><span class="line">        n = get_square_num(n)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(isHappy2(<span class="number">19</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="containsNearbyDuplicate-https-leetcode-cn-com-problems-contains-duplicate-ii"><a href="#containsNearbyDuplicate-https-leetcode-cn-com-problems-contains-duplicate-ii" class="headerlink" title="containsNearbyDuplicate(https://leetcode-cn.com/problems/contains-duplicate-ii/)"></a>containsNearbyDuplicate(<a href="https://leetcode-cn.com/problems/contains-duplicate-ii/">https://leetcode-cn.com/problems/contains-duplicate-ii/</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的 绝对值 至多为 k。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 1:</span></span><br><span class="line"><span class="comment"># 输入: nums = [1,2,3,1], k = 3</span></span><br><span class="line"><span class="comment"># 输出: true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2:</span></span><br><span class="line"><span class="comment"># 输入: nums = [1,0,1,1], k = 1</span></span><br><span class="line"><span class="comment"># 输出: true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 3:</span></span><br><span class="line"><span class="comment"># 输入: nums = [1,2,3,1,2,3], k = 2</span></span><br><span class="line"><span class="comment"># 输出: false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/contains-duplicate-ii</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.全局一遍遍历即可，时间复杂度O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">containsNearbyDuplicate1</span>(<span class="params">nums, k</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">0</span> <span class="keyword">or</span> k &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    k_dict = <span class="built_in">dict</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[i] <span class="keyword">in</span> k_dict <span class="keyword">and</span> i-k_dict[nums[i]] &lt;=k:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        k_dict[nums[i]] = i</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.维护一个为K大小的滑动窗口，每次去这个为k大小的滑动窗口中去查找有没有nums[i] == nums[j]      </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">containsNearbyDuplicate2</span>(<span class="params">nums, k</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">0</span> <span class="keyword">or</span> k &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    k_set = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[i] <span class="keyword">in</span> k_set:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        k_set.add(nums[i])</span><br><span class="line">        <span class="comment"># 维护大小为k的滑动窗口</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(k_set) == k+<span class="number">1</span>:</span><br><span class="line">            k_set.remove(nums[i-k])</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h4 id=&quot;排序算法&quot;&gt;&lt;a href=&quot;#排序算法&quot; class=&quot;headerlink&quot; title=&quot;排序算法&quot;&gt;&lt;/a&gt;排序算法&lt;/h4&gt;&lt;h5 id=&quot;选择排序&quot;&gt;&lt;a href=&quot;#选择排序&quot; class=&quot;headerlink&quot; tit</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Kafka</title>
    <link href="http://example.com/2021/05/22/Kafka/"/>
    <id>http://example.com/2021/05/22/Kafka/</id>
    <published>2021-05-22T09:29:03.000Z</published>
    <updated>2021-05-23T15:20:38.151Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Kafka入门篇"><a href="#Kafka入门篇" class="headerlink" title="Kafka入门篇"></a>Kafka入门篇</h4><h5 id="Kafka下载"><a href="#Kafka下载" class="headerlink" title="Kafka下载"></a>Kafka下载</h5><p>可以登录kafka官网进行下载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;kafka.apache.org&#x2F;downloads.html</span><br></pre></td></tr></table></figure><h5 id="kafka的基本概念"><a href="#kafka的基本概念" class="headerlink" title="kafka的基本概念"></a>kafka的基本概念</h5><h6 id="kafka作为一个分布式的流平台，这到底意味着什么"><a href="#kafka作为一个分布式的流平台，这到底意味着什么" class="headerlink" title="kafka作为一个分布式的流平台，这到底意味着什么?"></a>kafka作为一个分布式的流平台，这到底意味着什么?</h6><ul><li><p><strong>我们认为，一个流处理平台意味着三个关键能力</strong></p><ol><li>发布和订阅消息(流)，可靠的获取系统和应用程序之间的数据。</li><li>构建实时流的应用程序，对数据流进行抓换或者反应。</li></ol></li><li><p><strong>首先理解几个概念：</strong></p><ol><li>Kafka作为一个集群运行在一个或者多个服务器上。</li><li>kafka集群存储的消息是以topic为类别记录的。</li><li>每个消息是由一个key，一个value和时间戳构成。</li></ol></li><li><p><strong>kafka有四个核心API:</strong></p><ol><li><p>应用程序使用 <a href="https://www.orchome.com/190">Producer API</a> 发布消息到1个或多个topic（主题）中。</p></li><li><p>应用程序使用 <a href="https://www.orchome.com/200">Consumer API</a> 来订阅一个或多个topic，并处理产生的消息。</p></li><li><p>应用程序使用 <a href="https://www.orchome.com/304">Streams API</a> 充当一个流处理器，从1个或多个topic消费输入流，并生产一个输出流到1个或多个输出topic，有效地将输入流转换到输出流。</p></li><li><p><a href="https://www.orchome.com/455">Connector API</a> 可构建或运行可重用的生产者或消费者，将topic连接到现有的应用程序或数据系统。例如，连接到关系数据库的连接器可以捕获表的每个变更。</p><p><img src="/2021/05/22/Kafka/kafka%E5%9B%9B%E4%B8%AA%E6%A0%B8%E5%BF%83API.png" alt="kafka核心API"></p><ul><li>Client和Server之间的通讯，是通过一条简单、高性能并且和开发语言无关的<a href="/fwd?link=https://kafka.apache.org/protocol.html">TCP协议</a>。并且该协议保持与老版本的兼容。Kafka提供了Java Client（客户端）。除了Java客户端外，还有非常多的<a href="/fwd?link=https://cwiki.apache.org/confluence/display/KAFKA/Clients">其它编程语言的客户端</a>。</li></ul></li></ol></li><li><p><strong>kafa中使用的基本术语:</strong></p><ul><li><h4 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Kafka将消息分门别类，每一类的消息称之为一个主题（Topic）。</span><br></pre></td></tr></table></figure></li><li><h4 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">发布消息的对象称之为主题生产者（Kafka topic producer）</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><h4 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">订阅消息并处理发布的消息的对象称之为主题消费者（consumers）</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><h4 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">已发布的消息保存在一组服务器中，称之为Kafka集群。集群中的每一个服务器都是一个代理（Broker）。 消费者可以订阅一个或多个主题（topic），并从Broker拉数据，从而消费这些已发布的消息。</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>主题和日志(Topic和Log)</strong>:</p><ul><li><p>让我们更深入的了解kafka中的topic。</p></li><li><p>topic是发布的消息的类别名，一个topic可以有零个，一个或者多个消费者订阅该主题的消息。</p></li><li><p>对于每个topic，kafka集群都会维护一个分区的log,就像下图中所示:</p><p><img src="/2021/05/22/Kafka/Kafka%E7%9A%84topic.png" alt="Kafka的topic"></p></li><li><p>每一个分区都是一个顺序的，不可变的消息队列，并且可以持续的添加。分区中的消息都被分了一个序列号，称之为偏移量(offset),在每个分区中此偏移量都是唯一的。</p></li><li><p>Kafka集群保持所有的消息，直到它们过期（无论消息是否被消费）。实际上消费者所持有的仅有的元数据就是这个offset（偏移量），也就是说offset由消费者来控制：正常情况当消费者消费消息的时候，偏移量也线性的的增加。但是实际偏移量由消费者控制，消费者可以将偏移量重置为更早的位置，重新读取消息。可以看到这种设计对消费者来说操作自如，一个消费者的操作不会影响其它消费者对此log的处理。</p><p><img src="/2021/05/22/Kafka/%E6%B6%88%E8%B4%B9topic.png" alt="消费topic"></p></li></ul></li><li><p><strong>分布式</strong></p><ul><li>Log的分区被分布到集群中的多个服务器上。每个服务器处理它分到的分区。 根据配置每个分区还可以复制到其它服务器作为备份容错。 每个分区有一个leader，零或多个follower。Leader处理此分区的所有的读写请求，而follower被动的复制数据。如果leader宕机，其它的一个follower会被推举为新的leader。 一台服务器可能同时是一个分区的leader，另一个分区的follower。 这样可以平衡负载，避免所有的请求都只让一台或者某几台服务器处理。</li></ul></li><li><p><strong>Geo-Replication(异地数据同步技术)</strong></p><ul><li>Kafka MirrorMaker为群集提供<code>geo-replication</code>支持。借助<code>MirrorMaker</code>，消息可以跨多个数据中心或云区域进行复制。 您可以在active/passive场景中用于备份和恢复; 或者在active/passive方案中将数据置于更接近用户的位置，或数据本地化。</li></ul></li><li><p><strong>生产者(Producer)</strong></p><ul><li>生产者往某个Topic上发布消息。生产者也负责选择发布到Topic上的哪一个分区。最简单的方式从分区列表中轮流选择。也可以根据某种算法依照权重选择分区。开发者负责如何选择分区的算法。</li></ul></li><li><p><strong>消费者(Consumers)</strong></p><ul><li><p>通常来讲，消息模型可以分为两种， 队列和发布-订阅式。 队列的处理方式是 一组消费者从服务器读取消息，一条消息只有其中的一个消费者来处理。在发布-订阅模型中，消息被广播给所有的消费者，接收到消息的消费者都可以处理此消息。Kafka为这两种模型提供了单一的消费者抽象模型： 消费者组 （consumer group）。 消费者用一个消费者组名标记自己。 一个发布在Topic上消息被分发给此消费者组中的一个消费者。 假如所有的消费者都在一个组中，那么这就变成了queue模型。 假如所有的消费者都在不同的组中，那么就完全变成了发布-订阅模型。 更通用的， 我们可以创建一些消费者组作为逻辑上的订阅者。每个组包含数目不等的消费者， 一个组内多个消费者可以用来扩展性能和容错。正如下图所示：</p><p><img src="/2021/05/22/Kafka/kafka%E6%B6%88%E8%B4%B9%E6%A8%A1%E5%9E%8B.png" alt="kafka消费模型"></p><p>2个kafka集群托管4个分区（P0-P3），2个消费者组，消费组A有2个消费者实例，消费组B有4个。</p><p>正像传统的消息系统一样，Kafka保证消息的顺序不变。 再详细扯几句。传统的队列模型保持消息，并且保证它们的先后顺序不变。但是， 尽管服务器保证了消息的顺序，消息还是异步的发送给各个消费者，消费者收到消息的先后顺序不能保证了。这也意味着并行消费将不能保证消息的先后顺序。用过传统的消息系统的同学肯定清楚，消息的顺序处理很让人头痛。如果只让一个消费者处理消息，又违背了并行处理的初衷。 在这一点上Kafka做的更好，尽管并没有完全解决上述问题。 Kafka采用了一种分而治之的策略：分区。 因为Topic分区中消息只能由消费者组中的唯一一个消费者处理，所以消息肯定是按照先后顺序进行处理的。但是它也仅仅是保证Topic的一个分区顺序处理，不能保证跨分区的消息先后处理顺序。 所以，如果你想要顺序的处理Topic的所有消息，那就只提供一个分区。</p></li></ul></li><li><p><strong>kafka的保证</strong></p><ul><li>生产者发送到一个特定的Topic的分区上，消息将会按照它们发送的顺序依次加入，也就是说，如果一个消息M1和M2使用相同的producer发送，M1先发送，那么M1将比M2的offset低，并且优先的出现在日志中</li><li>消费者收到的消息也是此顺序。</li><li>如果一个Topic配置了复制因子（replication factor）为N， 那么可以允许N-1服务器宕机而不丢失任何已经提交（committed）的消息。</li></ul></li></ul><h5 id="kafka的应用场景"><a href="#kafka的应用场景" class="headerlink" title="kafka的应用场景"></a>kafka的应用场景</h5><h5 id="快速启动kafka"><a href="#快速启动kafka" class="headerlink" title="快速启动kafka"></a>快速启动kafka</h5><h6 id="kafka的生态系统"><a href="#kafka的生态系统" class="headerlink" title="kafka的生态系统"></a>kafka的生态系统</h6>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;Kafka入门篇&quot;&gt;&lt;a href=&quot;#Kafka入门篇&quot; class=&quot;headerlink&quot; title=&quot;Kafka入门篇&quot;&gt;&lt;/a&gt;Kafka入门篇&lt;/h4&gt;&lt;h5 id=&quot;Kafka下载&quot;&gt;&lt;a href=&quot;#Kafka下载&quot; class=&quot;header</summary>
      
    
    
    
    <category term="中间件" scheme="http://example.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="中间件" scheme="http://example.com/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="http://example.com/2021/04/20/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://example.com/2021/04/20/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2021-04-20T14:01:49.000Z</published>
    <updated>2021-04-24T15:37:50.454Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h4 id="动态规划算法"><a href="#动态规划算法" class="headerlink" title="动态规划算法"></a>动态规划算法</h4><p><strong>定义</strong>:</p><p>动态规划算法是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决。<br>动态规划算法的基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。</p><p>我们可以先以一个简单的斐波那契数列入手，慢慢的理解动态规划的的思想</p><h5 id="斐波那契"><a href="#斐波那契" class="headerlink" title="斐波那契"></a>斐波那契</h5><h6 id="自顶向下的求解方式"><a href="#自顶向下的求解方式" class="headerlink" title="自顶向下的求解方式"></a>自顶向下的求解方式</h6><p>第一种方式:最原始的递归求解方式,存在大量重复计算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n&lt;<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> fib(n-<span class="number">1</span>)+fib(n-<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">t1 = <span class="built_in">int</span>(<span class="built_in">round</span>(time.time() * <span class="number">1000</span>))</span><br><span class="line">res = fib(<span class="number">20</span>)</span><br><span class="line">t2 = <span class="built_in">int</span>(<span class="built_in">round</span>(time.time() * <span class="number">1000</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;the res is &#123;0&#125; use time is &#123;1&#125;&quot;</span>.<span class="built_in">format</span>(res,(t2-t1)))</span><br></pre></td></tr></table></figure><p><img src="/2021/04/20/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E9%87%8D%E5%A4%8D%E8%AE%A1%E7%AE%97.png" alt="重复计算"></p><p>如上图，假如我们计算n=4的时候就重复计算了fib(2)，这还是n=4，如果n更大一些，那么重复计算的节点就更多了，因此我们可以用一个数组来记录每次每个节点计算的值，每次计算前都先去查下这个记录的数组，如果已经计算的话就不需要再次计算了，这样的话能减少重复计算的次数，时间效率上就更高一些。</p><p>第二种方式:记忆搜素优化，用一个数组来来记录每个计算过的值，如果已经计算过了那么就不要再次计算，减少计算次数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="comment"># 用一个数组来记录每个n计算过的值</span></span><br><span class="line">    mem = [-<span class="number">1</span>] * (n+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> mem[n] == -<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> fib(n-<span class="number">1</span>) + fib(n-<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> mem[n]</span><br><span class="line">t1 = <span class="built_in">int</span>(<span class="built_in">round</span>(time.time() * <span class="number">1000</span>))</span><br><span class="line">res = fib(<span class="number">20</span>)</span><br><span class="line">t2 = <span class="built_in">int</span>(<span class="built_in">round</span>(time.time() * <span class="number">1000</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;the res is &#123;0&#125; use time is &#123;1&#125;&quot;</span>.<span class="built_in">format</span>(res,(t2-t1)))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="自下向上的求解算法"><a href="#自下向上的求解算法" class="headerlink" title="自下向上的求解算法"></a>自下向上的求解算法</h6><p>这种算法的思想大致就是由下往上推导计算，这样的话时间复杂度和空间复杂度都要更高效</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    pre = <span class="number">1</span></span><br><span class="line">    pre_pre = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">        res = pre + pre_pre</span><br><span class="line">        pre_pre = pre</span><br><span class="line">        pre = res</span><br><span class="line">    <span class="keyword">return</span> res % <span class="number">1000000007</span></span><br><span class="line">        </span><br><span class="line">t1 = <span class="built_in">int</span>(<span class="built_in">round</span>(time.time() * <span class="number">1000</span>))</span><br><span class="line">res = fib(<span class="number">20</span>)</span><br><span class="line">t2 = <span class="built_in">int</span>(<span class="built_in">round</span>(time.time() * <span class="number">1000</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;the res is &#123;0&#125; use time is &#123;1&#125;&quot;</span>.<span class="built_in">format</span>(res,(t2-t1)))</span><br></pre></td></tr></table></figure><h5 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h5><p><strong>题目</strong>:</p><p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>注意：</strong>给定 <em>n</em> 是一个正整数。</p><p><strong>思路</strong>: 我们仔细思考这道题会发现其实跟斐波那契是一个类型的题目，当阶梯为1和0的时候，只有1种走法(1)，当阶梯为2的时候，有2种走法(1-&gt;1, 2)，当阶梯为3的是时候，有三种走法(1-&gt;1-&gt;1, 1-&gt;2, 2-&gt;1)，当阶梯为n的时候，有f(n-1)+f(n-2)种走法，因此可以转发为斐波那契数列问题处理，代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">claim_stairs</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">or</span> n==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    pre = <span class="number">1</span></span><br><span class="line">    pre_pre = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">        res = pre_pre+pre</span><br><span class="line">        pre_pre = pre</span><br><span class="line">        pre = res</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h5 id="三角形最小路径和"><a href="#三角形最小路径和" class="headerlink" title="三角形最小路径和"></a>三角形最小路径和</h5><p><strong>题目:</strong></p><p>给定一个三角形 triangle ，找出自顶向下的最小路径和。</p><p>每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 </p><p>输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]<br>输出：11<br>解释：如下面简图所示：<br>   2<br>  3 4<br> 6 5 7<br>4 1 8 3<br>自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。</p><p><strong>思路:</strong></p><h5 id><a href="#" class="headerlink" title></a></h5>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h4 id=&quot;动态规划算法&quot;&gt;&lt;a href=&quot;#动态规划算法&quot; class=&quot;headerlink&quot; title=&quot;动态规划算法&quot;&gt;&lt;/a&gt;动态规划算法&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;动态规划算法是通过拆分问题</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux相关</title>
    <link href="http://example.com/2021/04/11/Linux%E7%9B%B8%E5%85%B3/"/>
    <id>http://example.com/2021/04/11/Linux%E7%9B%B8%E5%85%B3/</id>
    <published>2021-04-11T14:45:47.000Z</published>
    <updated>2021-04-20T13:33:01.925Z</updated>
    
    
    
    
    <category term="Linux相关" scheme="http://example.com/categories/Linux%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="Linux相关" scheme="http://example.com/tags/Linux%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>中间件</title>
    <link href="http://example.com/2021/04/11/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <id>http://example.com/2021/04/11/%E4%B8%AD%E9%97%B4%E4%BB%B6/</id>
    <published>2021-04-11T14:45:38.000Z</published>
    <updated>2021-05-22T08:14:30.646Z</updated>
    
    
    
    
    <category term="中间件" scheme="http://example.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="中间件" scheme="http://example.com/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>项目</title>
    <link href="http://example.com/2021/04/11/%E9%A1%B9%E7%9B%AE/"/>
    <id>http://example.com/2021/04/11/%E9%A1%B9%E7%9B%AE/</id>
    <published>2021-04-11T14:45:30.000Z</published>
    <updated>2021-04-13T13:47:34.464Z</updated>
    
    
    
    
    <category term="项目" scheme="http://example.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="项目" scheme="http://example.com/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>算法</title>
    <link href="http://example.com/2021/04/11/%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2021/04/11/%E7%AE%97%E6%B3%95/</id>
    <published>2021-04-11T14:45:23.000Z</published>
    <updated>2021-04-13T13:47:25.403Z</updated>
    
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Python</title>
    <link href="http://example.com/2021/04/11/Python/"/>
    <id>http://example.com/2021/04/11/Python/</id>
    <published>2021-04-11T14:45:12.000Z</published>
    <updated>2021-04-13T13:48:32.657Z</updated>
    
    
    
    
    <category term="Python" scheme="http://example.com/categories/Python/"/>
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="http://example.com/2021/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>http://example.com/2021/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</id>
    <published>2021-04-11T14:33:36.000Z</published>
    <updated>2021-05-22T09:26:17.817Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h3 id="计算机分层"><a href="#计算机分层" class="headerlink" title="计算机分层"></a>计算机分层</h3><ol><li><p>目前市面上存在的有OSI七层模型,TCP/IP四层协议，以及五层协议，如图所示:</p><p><img src="/2021/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82.png" alt="不同网络分层"></p></li><li><p>我们以标准的OSI七层模型为例，自下向上的阐述一下每层的作用 </p><p><img src="/2021/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B.png" alt="OSI七层模型"></p><ul><li><p><strong>物理层</strong></p><p>机械，电子，定时接收通信信道上的原始比特流,主要定义了一些物理设备的标准 ，如网线的类型，光纤接口的类型，主要作用是传输比特流，即我们说的0101数据，将他们转换成电流 强弱传输(数模转换)，网卡工作在这一层</p></li><li><p><strong>数据链路层</strong></p><p>将比特流封装成帧发送，并且这一层还提供了差错检测机制(即发送比特流的过程中可能会发生误传重传或者错传的情况)，交换机工作在这一层</p></li><li><p><strong>网络层</strong></p><p>点对点发送时可能需要经过多个节点，那么他是如何找到正确的目标地址的呢?这时便有了网络层,控制子网的运行，如逻辑编址，分组传输，路由传输。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 <strong>IP 协议</strong>，因此分组也叫 <strong>IP 数据报</strong> ，简称 <strong>数据报</strong>。</p><p>这里要注意：<strong>不要把运输层的“用户数据报 UDP ”和网络层的“ IP 数据报”弄混</strong>。另外，无论是哪一层的数据单元，都可笼统地用“分组”来表示。</p><p>这里强调指出，网络层中的“网络”二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称。路由器便工作在这一层</p></li><li><p><strong>传输层</strong></p><p>接受上一层的数据，在必要的时候把数据进行分割，并且将这些数据交给网络层，且保证这些数据段能有效的到达对端 ，该层有两个重要的协议分别是TCP协议和UDP协议</p></li><li><p><strong>会话层</strong></p><p>不同机器上的用户之间建立以及管理会话</p></li><li><p><strong>表示层</strong></p><p>信息的语法语义以及他们的关联，如加密解密，转换翻译，压缩解压缩等等</p></li><li><p><strong>应用层</strong></p><p>**应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。**应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如**域名系统DNS**，支持万维网应用的 <strong>HTTP协议</strong>，支持电子邮件的 <strong>SMTP协议</strong>等等。我们把应用层交互的数据单元称为报文</p><p><strong>域名系统</strong></p><blockquote><p>域名系统(Domain Name System缩写 DNS，Domain Name被译为域名)是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。（百度百科）例如：一个公司的 Web 网站可看作是它在网上的门户，而域名就相当于其门牌地址，通常域名都使用该公司的名称或简称。例如上面提到的微软公司的域名，类似的还有：IBM 公司的域名是 <a href="http://www.ibm.com、oracle/">www.ibm.com、Oracle</a> 公司的域名是 <a href="http://www.oracle.com、cisco公司的域名是/">www.oracle.com、Cisco公司的域名是</a> <a href="http://www.cisco.com/">www.cisco.com</a> 等。</p></blockquote><p><strong>HTTP协议</strong></p><blockquote><p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW（万维网） 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。（百度百科）</p></blockquote></li></ul></li></ol><ol start="3"><li><p>不同层次的简要配合流程:</p><p><img src="/2021/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%AF%8F%E5%B1%82%E5%B7%A5%E4%BD%9C%E4%BD%9C%E7%94%A8.png" alt="工作流程"></p></li></ol><h3 id="TCP三次握手与四次挥手机制"><a href="#TCP三次握手与四次挥手机制" class="headerlink" title="TCP三次握手与四次挥手机制"></a>TCP三次握手与四次挥手机制</h3><ol><li><p><strong>传输控制协议TCP简介</strong></p><ul><li>面向连接的，可靠的，基于字节流的传输层通信协议</li><li>将应用层的数据流分割成报文段并发送给目标节点的TCP层</li><li>数据包都有序号，对方收到则发送ACK确认，未收到则重传</li><li>使用校验和检验数据在传输过程中是否有误 </li></ul></li><li><p><strong>TCP的报文结构如图所示:</strong></p><p><img src="/2021/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/tcp%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84.png" alt="tcp三次握手"></p></li></ol><ul><li><p>序列号seq：占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。</p></li><li><p>确认号ack：占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。</p></li><li><p>确认ACK：占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效</p></li><li><p>同步SYN：连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。</p></li><li><p>终止FIN：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接</p></li><li><p>PS：ACK、SYN和FIN这些大写的单词表示标志位，其值要么是1，要么是0；ack、seq小写的单词表示序号</p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>URG</td><td>紧急指针是否有效。为1，表示某一位需要被优先处理</td></tr><tr><td>ACK</td><td>确认号是否有效，一般置为1</td></tr><tr><td>PSH</td><td>提示接收端应用程序立即从TCP缓冲区把数据读走</td></tr><tr><td>RST</td><td>对方要求重建建立，复位</td></tr><tr><td>SYN</td><td>请求建立连接，并且在其序列号的字段进行序列号的初始值设定。建立连接，设置为1</td></tr><tr><td>FIN</td><td>希望断开连接</td></tr></tbody></table></li></ul><ol start="3"><li><strong>tcp三次握手</strong></li></ol><p><img src="/2021/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="tcp三次握手"></p><ul><li><p>第一次握手: 建立连接时，客户端会发送一个syn=j包和一个seq=x包到服务端,并且进去到SYN_SENT状态，等待服务端确认</p></li><li><p>第二次握手: 服务端收到来自客户端的syn包，必须确认客户端的SYN(ack=j+1),并且发送自己的seq=y包，即SYN+ACK包，此时服务端进入到SYN_RECV状态</p></li><li><p>第三次握手: 客户端收到来自服务端的ACK+SYN包，向服务器发送确认包ACK(ack=y+1),此包发送完毕，双方都进入到ESTABLISHED（TCP连接成功）状态，完成三次握手</p></li></ul><ol start="4"><li><p><strong>tcp四次挥手</strong></p><p><img src="/2021/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="四次挥手"></p><ul><li><p><strong>第一次</strong>: 客户端发送一个FIN，用来关闭客户端到服务端的数据传输，客户端进入到FIN_WAIT_1状态</p></li><li><p><strong>第二次</strong>:服务端收到FIN后，发送一个ACK给客户端，确认序列号为收到的序号+1（与SYN相同，一个FIN占用一个序号），Server进入到CLOSE_WAIT状态</p></li><li><p><strong>第三次</strong>: 服务端发送一个FIN，用来关闭服务端到客户端的数据传输，服务端进入到LAST_ACK状态</p></li><li><p><strong>第四次:</strong> 客户端收到FIN后，客户端进入到TIME_WAIT状态，接着发送一个ACK给服务端，确认序号为收到的序号+1,服务端进入到CLOSED状态，完成四次挥手</p></li></ul><ol start="5"><li><p>【<strong>常见问题</strong>】</p><ul><li><p>【问题1】<strong>TCP连接必须经过2MSL后才真正释放掉，为什么 需要等待2MSL的时间段的TIME_WAIT状态再进入到CLOSE状态而不是立马就进入到CLOSE状态?</strong></p><ul><li><p>确保有足够的时间让对方收到ACK包。如果被动关闭的那一端没有收到ACK包，那么就会触发被动关闭方重发FIN包，一来一回刚好是2MSL的时间段</p></li><li><p>避免新旧连接混淆。有些路由器会缓存数据包，如果连接被重用了，那么那些延迟收到的包就有可能会跟新的数据包混淆在一起</p></li></ul></li><li><p>【问题2】<strong>为什么是需要四次握手才能断开连接？而建立连接确实三次握手？</strong></p><ul><li>因为全双工，发送方和接收方都需要FIN和ACK报文。</li><li>当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手</li></ul></li><li><p>【问题3】<strong>为什么不能两次握手建立连接？</strong></p><ul><li><p>3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。</p></li><li><p><strong>为了初始化Sequence Number的初始值。</strong>现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。</p></li></ul></li><li><p>【问题4】<strong>如果已经建立了连接，但是客户端突然出现故障下线了怎么办(即所谓的SYN flood攻击)？</strong></p><ul><li>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</li></ul></li><li><p>【问题5】<strong>服务器产生大量的time_wait怎么办?</strong></p><ul><li><p>首先大量的TIME_WAIT造成的影响?</p><ul><li><p> 在<strong>高并发短连接</strong>的TCP服务器上，当服务器处理完请求后立刻主动正常关闭连接。这个场景下会出现大量socket处于TIME_WAIT状态。如果客户端的并发量持续很高，此时部分客户端就会显示连接不上。</p></li><li><p>那么怎么去处理这种情况呢?</p><ul><li><p>首先我们可以用linux命令去查看TCP的连接数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">netstat -ant|awk &#39;&#x2F;^tcp&#x2F; &#123;++S[$NF]&#125; END &#123;for(a in S) print (a,S[a])&#125;&#39;</span><br><span class="line">LAST_ACK 14</span><br><span class="line">SYN_RECV 348</span><br><span class="line">ESTABLISHED 70</span><br><span class="line">FIN_WAIT1 229</span><br><span class="line">FIN_WAIT2 30</span><br><span class="line">CLOSING 33</span><br><span class="line">TIME_WAIT 18122</span><br></pre></td></tr></table></figure></li></ul></li><li><p>状态描述:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CLOSED：无连接是活动的或正在进行</span><br><span class="line">LISTEN：服务器在等待进入呼叫</span><br><span class="line">SYN_RECV：一个连接请求已经到达，等待确认</span><br><span class="line">SYN_SENT：应用已经开始，打开一个连接</span><br><span class="line">ESTABLISHED：正常数据传输状态</span><br><span class="line">FIN_WAIT1：应用说它已经完成</span><br><span class="line">FIN_WAIT2：另一边已同意释放</span><br><span class="line">ITMED_WAIT：等待所有分组死掉</span><br><span class="line">CLOSING：两边同时尝试关闭</span><br><span class="line">TIME_WAIT：另一边已初始化一个释放</span><br><span class="line">LAST_ACK：等待所有分组死掉</span><br></pre></td></tr></table></figure></li><li><p>编辑内核文件/etc/sysctl.conf,加入以下内容:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_syncookies &#x3D; 1 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；</span><br><span class="line">net.ipv4.tcp_tw_reuse &#x3D; 1 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；</span><br><span class="line">net.ipv4.tcp_tw_recycle &#x3D; 1 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。</span><br><span class="line">net.ipv4.tcp_fin_timeout 修改系默认的 TIMEOUT 时间</span><br></pre></td></tr></table></figure></li><li><p>然后执行 /sbin/sysctl -p 让参数生效.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;sysctl.conf是一个允许改变正在运行中的Linux系统的接口，它包含一些TCP&#x2F;IP堆栈和虚拟内存系统的高级选项，修改内核参数永久生效。</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>上面的配置简单来说，就是打开系统的TIMEWAIT的重用和快速回收</p></li><li><p>如果以上配置调优后性能还是不理想，可继续修改一下配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;sysctl.conf</span><br><span class="line">net.ipv4.tcp_keepalive_time &#x3D; 1200 </span><br><span class="line">#表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为20分钟。</span><br><span class="line">net.ipv4.ip_local_port_range &#x3D; 1024 65000 </span><br><span class="line">#表示用于向外连接的端口范围。缺省情况下很小：32768到61000，改为1024到65000。</span><br><span class="line">net.ipv4.tcp_max_syn_backlog &#x3D; 8192 </span><br><span class="line">#表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数。</span><br><span class="line">net.ipv4.tcp_max_tw_buckets &#x3D; 5000 </span><br><span class="line">#表示系统同时保持TIME_WAIT套接字的最大数量，如果超过这个数字，TIME_WAIT套接字将立刻被清除并打印警告信息。</span><br><span class="line">默认为180000，改为5000。对于Apache、Nginx等服务器，上几行的参数可以很好地减少TIME_WAIT套接字数量，但是对于 Squid，效果却不大。此项参数可以控制TIME_WAIT套接字的最大数量，避免Squid服务器被大量的TIME_WAIT套接字拖死。</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li></ol></li></ol><h3 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h3><ul><li><p><strong>UDP的特点</strong>:</p><ul><li>面向非连接</li><li>不维护连接状态，支持同时向多个客户端传输相同的消息</li><li> 数据包报头只有8个字节，额外开销较小</li><li>吞吐量只受限于数据生成率，传输速率以及机器性能</li></ul></li><li><p>尽最大努力交付，不保证可靠交付，不需要维持复杂的链接状态表</p></li><li><p><strong>UDP报文结构</strong>(报文头部8个字节)</p><p><img src="/2021/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/UDP%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84.png" alt="UDP报文结构"></p></li><li><p>TCP报文结构（报文头部20个字节）</p><p><img src="/2021/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/tcp%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84.png" alt="TCP报文结构"></p></li><li><p> <strong>两者区别</strong></p></li><li><p>TCP面向连接，而UDP面向无连接</p></li><li><p>TCP相对于UDP来说可靠性要高，因为TCP是有连接机制（<strong>可靠性</strong>）</p></li><li><p>TCP是有序的而UDP是无序的(<strong>有序性</strong>)</p></li><li><p>TCP较UDP来说速度较慢，因为TCP要握手挥手机制，UDP适合 对速度比较敏感的应用，如在线直播等(<strong>速度</strong>)</p></li><li><p>TCP(头部20字节)在量级上比UDP(头部8字节)要小(<strong>量级</strong>)</p></li></ul><h3 id="TCP的滑动窗口"><a href="#TCP的滑动窗口" class="headerlink" title="TCP的滑动窗口"></a>TCP的滑动窗口</h3><ol><li><strong>我们先来理解两个概念RTT和RTO</strong></li></ol><ul><li>RTT: 发送一个数据包到收到对应的ACK所花费的时间</li><li>RTO:重传时间间隔  </li><li>滑动窗口基于RTO</li></ul><ol start="2"><li><strong>TCP使用滑动窗口做流量控制与乱序重排</strong></li></ol><ul><li>保证TCP的可靠性</li><li>保证TCP的流控特性</li><li>报头的window：用于接收方通知发送方，自己还有多少缓冲区用来接收数据，发送方根据接收方的处理能力来发送数据，不会导致接收方处理不过来。</li></ul><p><img src="/2021/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B.png" alt="窗口数据的计算过程"></p><ul><li><p>名词解释</p><p>LastByteWritten:上层应用最后一个写的数据，即当前程序准备好要发送的最新的一个数据（还没发送）</p><p>LastByteAcked：最后一个ACK(确认收到)的数据</p><p>LastByteSent：最后一个已经发送的数据，还没收到ack</p><p>LastByteRead：接收端，读取到的并且已经处理的最后一条数据（已经回复ACK的）</p><p>NextByteExpected：已经收到的连续数据中最大的一条（还没回复ACK的）</p><p>LastByteRecvd：已收到的最后一条数据（不连续）</p></li><li><p>窗口数据的计算过程</p><ol><li><p><strong>接收方计算AdvertisedWindow</strong>：</p><ul><li><p>AdvertisedWindow:建议发送端发送的最大数据量</p></li><li><p>AdvertisedWindow = MaxRcvBuffer - (LastByteRecvd-LastByteRead)</p></li><li><p>MaxRcvBuffer接收端缓存池大小</p></li></ul></li><li><p><strong>将AdvertisedWindow发送到发送方，发送方根据AdvertisedWindow计算EffectiveWindow</strong></p><ul><li>EffectiveWindow：发送方窗口内，剩余可发送的最大数据量</li><li>EffectiveWindow = AdvertisedWindow - (LastByteSent-LastByteAcked)</li></ul></li></ol></li><li><p><strong>滑动窗口的基本原理(滑动窗口要比(接收，发送)缓存小)</strong></p></li></ul><ol><li><strong>TCP发送方</strong>:滑动窗口：Category#2 + Category#3,当发送方收到接收方的数据ack时,窗口就会滑动。</li></ol><p><img src="/2021/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E5%8F%91%E9%80%81%E6%96%B9.png" alt="TCP发送方"></p><ol start="2"><li><strong>TCP接收方</strong>:接收窗口：Category#3,当接收方收到连续的数据后并且发出ACK信号后，窗口就会滑动<img src="/2021/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E6%8E%A5%E6%94%B6%E6%96%B9.png" alt="TCP接受方"></li></ol><ul><li><strong>最后总结:</strong><ul><li>流量控制:<ul><li>滑动窗口的大小可以依据一定策略动态调整，应用会根据自身处理能力的变化，通过本端TCP接收窗口的大小的控制，实现对端的发送窗口改变进行流量控制。</li><li>接收方通过计算得出AdvertisedWindow，并发送给发送方。</li><li>发送方：根据AdvertisedWindow计算可发送最大的数据量EffectiveWindow。</li></ul></li><li>乱序控制:<ul><li>接收方：按连续顺序确认接收并发送ack信号。</li><li>发送方  ：按连续顺序发送数据。</li></ul></li></ul></li></ul><h3 id="HTTP相关"><a href="#HTTP相关" class="headerlink" title="HTTP相关"></a>HTTP相关</h3><ol><li><p><strong>超文本传输协议HTTP的主要特点:</strong></p><ul><li>支持客户/服务器模式</li><li>简单快速</li><li>灵活</li><li>无连接 </li><li>无状态 </li></ul></li><li><p><strong>HTTP请求结构</strong>：</p><ul><li>请求行</li><li>请求头</li><li>空行(即便请求正文没有，也要有一行空行表示请求头结束 )</li><li>请求正文</li></ul><p><img src="/2021/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E8%AF%B7%E6%B1%82%E7%BB%93%E6%9E%84.png" alt="HTTP请求结构"></p></li><li><p><strong>HTTP响应报文结构:</strong></p><ul><li>响应行</li><li>响应头</li><li>空行</li><li>响应正文</li></ul></li><li><p><strong>请求/响应的步骤</strong>:</p><ul><li>客户端连接到WEB服务器</li><li>发送HTTP请求</li><li>服务器接受请求并返回HTTP响应</li><li>释放连接TCP连接</li><li>客户端浏览器解析HTML内容</li></ul></li><li><p><strong>在浏览器地址栏键入URL，按下回车之后经历的流程:</strong></p><ul><li>DNS解析(浏览器缓存-&gt;系统缓存-&gt;路由器缓存-&gt;IPS服务器缓存-&gt;根域名服务器缓存-&gt;顶级域名器缓存）以此查找</li><li>TCP连接，即三次握手机制</li><li>发送HTTP请求</li><li>服务器处理HTTP请求并返回HTTP报文</li><li>浏览器解析渲染页面</li><li>连接结束，即四次挥手机制</li></ul></li><li><p><strong>HTTP状态码:</strong></p><ul><li>1XX：指示请求—表示请求已接收，继续处理</li><li>2XX: 成功–表示请求已经被成功接收，理解，接受</li><li>3XX：重定向–要完成请求必须进行更进一步的操作</li><li>4XX:客户端错误–请求有语法错误或者请求无法实现</li><li>5XX:服务端错误–服务器未能实现合法的请求</li></ul></li><li><p><strong>HTTP和HTTPS的区别:</strong></p><ul><li><p>HTTPS简介:可以理解成HTTPS=HTTP+SSL</p><p><img src="/2021/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS%E7%AE%80%E4%BB%8B.png" alt="HTTPS简介"></p></li><li><p>SSL简介(安全套接层):</p><ul><li><p> 为网络通信提供了安全以及数据完整性的一种安全协议</p></li><li><p>是操作系统对外的API，SSL3.0后更名为TLS</p></li><li><p>采用身份验证和数据加密保证网络通信的安全和数据的完整性</p><ul><li><p>加密的方式</p><ol><li>对称加密:加密和解密都使用同一个密钥(效率高，但不安全)(AES)</li><li>不对称加密:加密使用的密钥和解析使用的密钥是不同的(效率低，但安全性高)(RSA)</li><li>哈希算法:将任意长度的信息转换成固定长度的值，算法不可逆(MD5)</li><li>数字签名:证明某个消息或者文件是某人发出/认同的</li></ol></li><li><p><strong>HTTPS请求过程</strong>:</p><ul><li><p>首先，数据正文一般数据量较大，适用于对称加密，因为对称加密速度快，适应于大量数据加密，但是安全级别低，其中对称加密的密钥需要在网络中传输，容易被盗取；</p></li><li><p>其次，正因为对称加密的密钥易被盗取，所以我们需要对这个密钥进行加密，而且安全级别要求高，所以这个可以用非对称加密算法进行加密，原因是对称加密的密钥数据量小，非对称加密可以提供高安全级别和高响应速度</p><p><img src="/2021/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B.png" alt="HTTPS请求过程"></p><ol><li>客户端向服务器发起HTTPS的请求，连接到服务器的443端口</li><li>服务器将非对称加密的公钥以证书的形式回传给客户端</li><li>客户端接受到该公钥后进行验证，就是验证步骤2中服务器返回的证书，如果有问题，则HTTPS请求无法继续；如果没有问题，则上述公钥是合格的，客户端这个时候随机生成一个密钥，称为client key(客户端密钥)，即用于对称加密数据的密钥，然后使用前面的公钥对client key进行非对称加密成密文，至此，HTTPS中的第一次HTTP请求结束</li><li>客户端发起第二次HTTP请求，将加密之后的client key发送给服务器</li><li>服务器使用私钥进行解密，得到解密后的client key，然后使用client key对数据进行对称加密；</li><li>将对称加密后的数据发送给客户端，客户端收到后对密文进行对称解密，得到服务器发送的数据，这样HTTPS中的第二次HTTP请求结束。HTTPS请求完成。</li></ol></li></ul></li></ul></li><li><p><strong>区别总结:</strong></p><ul><li>HTTPS是密文传输，HTTP是明文传输；</li><li>默认连接的端口号是不同的，HTTPS是443端口，而HTTP是80端口；</li><li>HTTPS请求的过程需要对CA证书进行验证身份以保证客户端请求到正确的服务器端，传回的响应是来自于正确的服务器端，而HTTP则不需要CA证书；</li><li>HTTPS=HTTP+加密+认证+完整性保护</li></ul></li><li><p><strong>HTTPS真的很安全吗?</strong></p><ul><li><p>未必，可能发生<strong>中间人攻击</strong></p><p><img src="/2021/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB.png" alt="中间人攻击"></p></li></ul></li><li><p><strong>那么如何预防中间人攻击呢?</strong></p><ul><li>那么就需要一个强大的CA机构了，因为正经的 CA 证书，都是来自某个权威的 CA。如果某个 CA 足够权威，那么主流的操作系统（或浏览器）会内置该 CA 的“根证书”。（比如 Windows 中就内置了几十个权威 CA 的根证书）因此，浏览器就可以利用系统内置的根证书，来判断网站发过来的 CA 证书是不是某个 CA 颁发的。</li></ul></li></ul></li></ul></li></ol><p>​     </p><p>​     </p><p>​     </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h3 id=&quot;计算机分层&quot;&gt;&lt;a href=&quot;#计算机分层&quot; class=&quot;headerlink&quot; title=&quot;计算机分层&quot;&gt;&lt;/a&gt;计算机分层&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;目前市面上存在的有OSI七层模型,TCP/IP四层协议，以及五层协议，如</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>java</title>
    <link href="http://example.com/2021/04/11/java/"/>
    <id>http://example.com/2021/04/11/java/</id>
    <published>2021-04-11T12:46:24.000Z</published>
    <updated>2021-04-13T13:48:04.906Z</updated>
    
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
</feed>
