<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>coderYun</title>
  
  <subtitle>To Be Better</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-06-20T07:25:00.664Z</updated>
  <id>http://example.com/</id>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>链表相关</title>
    <link href="http://example.com/2021/06/09/%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3/"/>
    <id>http://example.com/2021/06/09/%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3/</id>
    <published>2021-06-09T12:54:06.000Z</published>
    <updated>2021-06-20T07:25:00.664Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h4 id="reverseList-https-leetcode-cn-com-problems-fan-zhuan-lian-biao-lcof"><a href="#reverseList-https-leetcode-cn-com-problems-fan-zhuan-lian-biao-lcof" class="headerlink" title="reverseList(https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/)"></a>reverseList(<a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/">https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例:</span></span><br><span class="line"><span class="comment"># 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span></span><br><span class="line"><span class="comment"># 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.三指针思路 不断往右边滑动</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseList1</span>(<span class="params">head</span>):</span></span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    pre, curr = head, head.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">if</span> head.<span class="built_in">next</span> == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    nex = head.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">    <span class="comment"># 处理第一个元素的下个指针指向None</span></span><br><span class="line">    pre.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> nex:</span><br><span class="line">        curr.<span class="built_in">next</span> = pre</span><br><span class="line">        pre = curr</span><br><span class="line">        curr = nex</span><br><span class="line">        nex = curr.<span class="built_in">next</span></span><br><span class="line">    <span class="comment"># 处理最后一个元素</span></span><br><span class="line">    curr.<span class="built_in">next</span> = pre</span><br><span class="line">    <span class="keyword">return</span> curr</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.更简洁的写法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseList2</span>(<span class="params">head</span>):</span></span><br><span class="line">    pre = <span class="literal">None</span></span><br><span class="line">    curr = head</span><br><span class="line">    <span class="keyword">while</span> curr:</span><br><span class="line">        nex = curr.<span class="built_in">next</span></span><br><span class="line">        curr.<span class="built_in">next</span> = pre</span><br><span class="line">        pre = curr</span><br><span class="line">        curr = nex</span><br><span class="line">    <span class="keyword">return</span> pre</span><br><span class="line"></span><br><span class="line">head = ListNode(<span class="number">1</span>)</span><br><span class="line">head.<span class="built_in">next</span> = ListNode(<span class="number">2</span>)</span><br><span class="line">head.<span class="built_in">next</span>.<span class="built_in">next</span> = ListNode(<span class="number">3</span>)</span><br><span class="line">head.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = ListNode(<span class="number">4</span>)</span><br><span class="line">res = reverseList1(head)</span><br><span class="line"><span class="keyword">while</span> res:</span><br><span class="line">    <span class="built_in">print</span>(res.val)</span><br><span class="line">    res = res.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="reverseBetween-https-leetcode-cn-com-problems-reverse-linked-list-ii"><a href="#reverseBetween-https-leetcode-cn-com-problems-reverse-linked-list-ii" class="headerlink" title="reverseBetween(https://leetcode-cn.com/problems/reverse-linked-list-ii)"></a>reverseBetween(<a href="https://leetcode-cn.com/problems/reverse-linked-list-ii">https://leetcode-cn.com/problems/reverse-linked-list-ii</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。</span></span><br><span class="line"><span class="comment"># 请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 1：</span></span><br><span class="line"><span class="comment"># 输入：head = [1,2,3,4,5], left = 2, right = 4</span></span><br><span class="line"><span class="comment"># 输出：[1,4,3,2,5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2：</span></span><br><span class="line"><span class="comment"># 输入：head = [5], left = 1, right = 1</span></span><br><span class="line"><span class="comment"># 输出：[5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/reverse-linked-list-ii</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span>(<span class="params">head, left, right</span>):</span></span><br><span class="line">    pre = <span class="literal">None</span></span><br><span class="line">    cur = head</span><br><span class="line">    <span class="comment"># pre指向要反转的那一段链表的前一个节点</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,left):</span><br><span class="line">        pre = cur</span><br><span class="line">        cur = cur.<span class="built_in">next</span></span><br><span class="line">    pre_temp = pre</span><br><span class="line">    cur_temp = cur</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># [left...right] 之间已经完成了链表反转 </span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(left,right+<span class="number">1</span>):</span><br><span class="line">        nex = cur.<span class="built_in">next</span> </span><br><span class="line">        cur.<span class="built_in">next</span> = pre</span><br><span class="line">        pre = cur</span><br><span class="line">        cur = nex</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 拼接左右边界的节点使得整体反转</span></span><br><span class="line">    <span class="keyword">if</span> left &gt; <span class="number">1</span>: <span class="comment"># 这种情况是为了考虑【left=1】的情况，即从头开始反转</span></span><br><span class="line">        pre_temp.<span class="built_in">next</span> = pre</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        head = pre</span><br><span class="line">    cur_temp.<span class="built_in">next</span> = cur</span><br><span class="line">    <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><h4 id="mergeTwoLists-https-leetcode-cn-com-problems-merge-two-sorted-lists"><a href="#mergeTwoLists-https-leetcode-cn-com-problems-merge-two-sorted-lists" class="headerlink" title="mergeTwoLists(https://leetcode-cn.com/problems/merge-two-sorted-lists/)"></a>mergeTwoLists(<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">https://leetcode-cn.com/problems/merge-two-sorted-lists/</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </span></span><br><span class="line"><span class="comment"># 示例 1：</span></span><br><span class="line"><span class="comment"># 输入：l1 = [1,2,4], l2 = [1,3,4]</span></span><br><span class="line"><span class="comment"># 输出：[1,1,2,3,4,4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2：</span></span><br><span class="line"><span class="comment"># 输入：l1 = [], l2 = []</span></span><br><span class="line"><span class="comment"># 输出：[]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 3：</span></span><br><span class="line"><span class="comment"># 输入：l1 = [], l2 = [0]</span></span><br><span class="line"><span class="comment"># 输出：[0]</span></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/merge-two-sorted-lists</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 双指针思路:一个指针分别指向一个链表进行遍历，每次比较把小的放到新的链表中</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val=<span class="number">0</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">l1, l2</span>):</span></span><br><span class="line">    <span class="keyword">if</span> l1 == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> l2</span><br><span class="line">    <span class="keyword">if</span> l2 == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> l1</span><br><span class="line">    newNode = ListNode(<span class="literal">None</span>)</span><br><span class="line">    res = newNode</span><br><span class="line">    <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">        <span class="keyword">if</span> l1.val &lt; l2.val:</span><br><span class="line">            res.<span class="built_in">next</span> = l1</span><br><span class="line">            l1 = l1.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res.<span class="built_in">next</span> = l2</span><br><span class="line">            l2 = l2.<span class="built_in">next</span></span><br><span class="line">        res = res.<span class="built_in">next</span></span><br><span class="line">    <span class="comment"># 当有一个链表如果没有遍历完，直接加到新的链表后即可，因为都是有序的链表</span></span><br><span class="line">    <span class="keyword">if</span>  l1:</span><br><span class="line">        res.<span class="built_in">next</span> = l1</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        res.<span class="built_in">next</span> = l2</span><br><span class="line">    <span class="keyword">return</span> newNode.<span class="built_in">next</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure><h4 id="deleteNode-https-leetcode-cn-com-problems-delete-node-in-a-linked-list"><a href="#deleteNode-https-leetcode-cn-com-problems-delete-node-in-a-linked-list" class="headerlink" title="deleteNode(https://leetcode-cn.com/problems/delete-node-in-a-linked-list)"></a>deleteNode(<a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list">https://leetcode-cn.com/problems/delete-node-in-a-linked-list</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为 要被删除的节点 。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 现有一个链表 -- head = [4,5,1,9]，它可以表示为:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 1：</span></span><br><span class="line"><span class="comment"># 输入：head = [4,5,1,9], node = 5</span></span><br><span class="line"><span class="comment"># 输出：[4,1,9]</span></span><br><span class="line"><span class="comment"># 解释：给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2：</span></span><br><span class="line"><span class="comment"># 输入：head = [4,5,1,9], node = 1</span></span><br><span class="line"><span class="comment"># 输出：[4,5,9]</span></span><br><span class="line"><span class="comment"># 解释：给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/delete-node-in-a-linked-list</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用要删除的节点的后一个节点的值覆盖掉要删除的节点的值，然后把该节点next指向next.next就好了</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span>(<span class="params">node</span>):</span></span><br><span class="line">    <span class="keyword">if</span> node == <span class="literal">None</span> <span class="keyword">or</span> node.<span class="built_in">next</span> == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    node.val = node.<span class="built_in">next</span>.val</span><br><span class="line">    node.<span class="built_in">next</span> = node.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure><h4 id="deleteDuplicates-https-leetcode-cn-com-problems-remove-duplicates-from-sorted-list"><a href="#deleteDuplicates-https-leetcode-cn-com-problems-remove-duplicates-from-sorted-list" class="headerlink" title="deleteDuplicates(https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)"></a>deleteDuplicates(<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除所有重复的元素，使每个元素 只出现一次 。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回同样按升序排列的结果链表。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  </span></span><br><span class="line"><span class="comment"># 示例 1：</span></span><br><span class="line"><span class="comment"># 输入：head = [1,1,2]</span></span><br><span class="line"><span class="comment"># 输出：[1,2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2：</span></span><br><span class="line"><span class="comment"># 输入：head = [1,1,2,3,3]</span></span><br><span class="line"><span class="comment"># 输出：[1,2,3]</span></span><br><span class="line"><span class="comment">#  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val=<span class="number">0</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.因为是顺序排好的链表，因此可以直接比较当前节点的值和下一个节点的值，如果一样就删除</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates2</span>(<span class="params">head</span>):</span></span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    </span><br><span class="line">    cur = head</span><br><span class="line">    <span class="keyword">while</span> cur.<span class="built_in">next</span>:</span><br><span class="line">        <span class="keyword">if</span> cur.val == cur.<span class="built_in">next</span>.val:</span><br><span class="line">            cur.<span class="built_in">next</span> = cur.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">head = ListNode(<span class="number">1</span>)</span><br><span class="line">head.<span class="built_in">next</span> = ListNode(<span class="number">1</span>)</span><br><span class="line">head.<span class="built_in">next</span>.<span class="built_in">next</span> = ListNode(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># head.next.next.next = ListNode(3)</span></span><br><span class="line"><span class="comment"># head.next.next.next.next = ListNode(5)</span></span><br><span class="line"></span><br><span class="line">res = deleteDuplicates2(head)</span><br><span class="line"><span class="keyword">while</span> res:</span><br><span class="line">    <span class="built_in">print</span>(res.val)</span><br><span class="line">    res = res.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><h4 id="deleteDuplicatesII-https-leetcode-cn-com-problems-remove-duplicates-from-sorted-list-ii"><a href="#deleteDuplicatesII-https-leetcode-cn-com-problems-remove-duplicates-from-sorted-list-ii" class="headerlink" title="deleteDuplicatesII(https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii)"></a>deleteDuplicatesII(<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 存在一个按升序排列的链表，给你这个链表的头节点 head ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中 没有重复出现 的数字。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回同样按升序排列的结果链表。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例一</span></span><br><span class="line"><span class="comment"># 输入：head = [1,2,3,3,4,4,5]</span></span><br><span class="line"><span class="comment"># 输出：[1,2,5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例二:</span></span><br><span class="line"><span class="comment"># 输入：head = [1,1,1,2,3]</span></span><br><span class="line"><span class="comment"># 输出：[2,3]</span></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val=<span class="number">0</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.迭代法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicatesII</span>(<span class="params">head</span>):</span></span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">    dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">    dummy.<span class="built_in">next</span> = head</span><br><span class="line">    cur = dummy</span><br><span class="line">    <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">and</span> cur.<span class="built_in">next</span>.<span class="built_in">next</span>:</span><br><span class="line">        <span class="comment"># 不相等就向下循环</span></span><br><span class="line">        <span class="keyword">if</span> cur.<span class="built_in">next</span>.val != cur.<span class="built_in">next</span>.<span class="built_in">next</span>.val:</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 相等的话就用一个变量暂时存储相等的值，每次去遍历下个节点是不是等于这个值，等于就删除，直到不相等</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            temp = cur.<span class="built_in">next</span>.val</span><br><span class="line">            <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">and</span> cur.<span class="built_in">next</span>.val == temp:</span><br><span class="line">                cur.<span class="built_in">next</span> = cur.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br><span class="line">         </span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.递归法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicatesII2</span>(<span class="params">head</span>):</span></span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    nex = head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> head.val == nex.val:</span><br><span class="line">        <span class="keyword">while</span> nex <span class="keyword">and</span> head.val == nex.val:</span><br><span class="line">            nex = nex.<span class="built_in">next</span></span><br><span class="line">        head = deleteDuplicatesII2(nex)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        head.<span class="built_in">next</span> = deleteDuplicatesII2(nex)</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="sort-list-https-leetcode-cn-com-problems-sort-list"><a href="#sort-list-https-leetcode-cn-com-problems-sort-list" class="headerlink" title="sort-list(https://leetcode-cn.com/problems/sort-list)"></a>sort-list(<a href="https://leetcode-cn.com/problems/sort-list">https://leetcode-cn.com/problems/sort-list</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进阶：</span></span><br><span class="line"><span class="comment"># 你可以在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序吗？</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 1:</span></span><br><span class="line"><span class="comment"># 输入：head = [4,2,1,3]</span></span><br><span class="line"><span class="comment"># 输出：[1,2,3,4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2：</span></span><br><span class="line"><span class="comment"># 输入：head = [-1,5,3,4,0]</span></span><br><span class="line"><span class="comment"># 输出：[-1,0,3,4,5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 3：</span></span><br><span class="line"><span class="comment"># 输入：head = []</span></span><br><span class="line"><span class="comment"># 输出：[]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/sort-list</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val=<span class="number">0</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回中间节点</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_mid_node</span>(<span class="params">head</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    dummy_head = ListNode(-<span class="number">1</span>)</span><br><span class="line">    dummy_head.<span class="built_in">next</span> = head</span><br><span class="line">    pre = dummy_head <span class="comment"># 设置一个虚拟头节点可以防止栈溢出</span></span><br><span class="line">    slow = head</span><br><span class="line">    fast = head</span><br><span class="line">    <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">        pre = slow</span><br><span class="line">        slow = slow.<span class="built_in">next</span></span><br><span class="line">        fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">    <span class="comment"># 前半部分链表和后半部分链表断开</span></span><br><span class="line">    pre.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> slow</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并两个有序链表</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort_list</span>(<span class="params">left, right</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> left:</span><br><span class="line">        <span class="keyword">return</span> right</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> right:</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">    res = ListNode(-<span class="number">1</span>)</span><br><span class="line">    cur = res</span><br><span class="line">    <span class="keyword">while</span> left <span class="keyword">and</span> right:</span><br><span class="line">        <span class="keyword">if</span> left.val &lt; right.val:</span><br><span class="line">            cur.<span class="built_in">next</span> = left</span><br><span class="line">            left = left.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur.<span class="built_in">next</span> = right</span><br><span class="line">            right = right.<span class="built_in">next</span></span><br><span class="line">        cur =cur.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">if</span> left:</span><br><span class="line">        cur.<span class="built_in">next</span> = left</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        cur.<span class="built_in">next</span> = right</span><br><span class="line">    <span class="keyword">return</span> res.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortList</span>(<span class="params">head</span>):</span></span><br><span class="line">    <span class="comment"># 1 递归结束条件</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 找到中间链表，并且断开链表进行递归</span></span><br><span class="line">    mid_node = get_mid_node(head)</span><br><span class="line"></span><br><span class="line">    left = sortList(head)</span><br><span class="line">    right = sortList(mid_node)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 合并两个有序链表</span></span><br><span class="line">    <span class="keyword">return</span> merge_sort_list(left, right)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="swapPairs-https-leetcode-cn-com-problems-swapping-nodes-in-a-linked-list"><a href="#swapPairs-https-leetcode-cn-com-problems-swapping-nodes-in-a-linked-list" class="headerlink" title="swapPairs(https://leetcode-cn.com/problems/swapping-nodes-in-a-linked-list/)"></a>swapPairs(<a href="https://leetcode-cn.com/problems/swapping-nodes-in-a-linked-list/">https://leetcode-cn.com/problems/swapping-nodes-in-a-linked-list/</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</span></span><br><span class="line"><span class="comment"># 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 1：</span></span><br><span class="line"><span class="comment"># 输入：head = [1,2,3,4]</span></span><br><span class="line"><span class="comment"># 输出：[2,1,4,3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2：</span></span><br><span class="line"><span class="comment"># 输入：head = []</span></span><br><span class="line"><span class="comment"># 输出：[]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 3：</span></span><br><span class="line"><span class="comment"># 输入：head = [1]</span></span><br><span class="line"><span class="comment"># 输出：[1]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置一个亚节点，并且四四指针的思路解决这道问题</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span>(<span class="params">head</span>):</span></span><br><span class="line">    dummy_head = ListNode(-<span class="number">1</span>)</span><br><span class="line">    dummy_head.<span class="built_in">next</span> = head</span><br><span class="line">    pre = dummy_head</span><br><span class="line">    <span class="keyword">while</span> pre.<span class="built_in">next</span> <span class="keyword">and</span> pre.<span class="built_in">next</span>.<span class="built_in">next</span>:</span><br><span class="line">        node1 = pre.<span class="built_in">next</span></span><br><span class="line">        node2 = node1.<span class="built_in">next</span></span><br><span class="line">        nex = node2.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 真正的反转</span></span><br><span class="line">        node2.<span class="built_in">next</span> = node1</span><br><span class="line">        node1.<span class="built_in">next</span> = nex</span><br><span class="line">        pre.<span class="built_in">next</span> = node2</span><br><span class="line">        pre = node1</span><br><span class="line">    <span class="keyword">return</span> dummy_head.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><h4 id="removeNthFromEnd-https-leetcode-cn-com-problems-remove-nth-node-from-end-of-list"><a href="#removeNthFromEnd-https-leetcode-cn-com-problems-remove-nth-node-from-end-of-list" class="headerlink" title="removeNthFromEnd(https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list)"></a>removeNthFromEnd(<a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list">https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</span></span><br><span class="line"><span class="comment"># 进阶：你能尝试使用一趟扫描实现吗？</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 1：</span></span><br><span class="line"><span class="comment"># 输入：head = [1,2,3,4,5], n = 2</span></span><br><span class="line"><span class="comment"># 输出：[1,2,3,5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2：</span></span><br><span class="line"><span class="comment"># 输入：head = [1], n = 1</span></span><br><span class="line"><span class="comment"># 输出：[]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 3：</span></span><br><span class="line"><span class="comment"># 输入：head = [1,2], n = 1</span></span><br><span class="line"><span class="comment"># 输出：[1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val=<span class="number">0</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 双指针滑动窗口思路</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span>(<span class="params">head, n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span> <span class="keyword">or</span> head == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    dummy_head = ListNode(-<span class="number">1</span>)</span><br><span class="line">    dummy_head.<span class="built_in">next</span> = head</span><br><span class="line">    slow = dummy_head</span><br><span class="line">    fast = dummy_head</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>):</span><br><span class="line">        fast = fast.<span class="built_in">next</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> slow <span class="keyword">and</span> fast:</span><br><span class="line">        slow = slow.<span class="built_in">next</span></span><br><span class="line">        fast = fast.<span class="built_in">next</span></span><br><span class="line">    </span><br><span class="line">    slow.<span class="built_in">next</span> = slow.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy_head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="removeElements-https-leetcode-cn-com-problems-remove-linked-list-elements"><a href="#removeElements-https-leetcode-cn-com-problems-remove-linked-list-elements" class="headerlink" title="removeElements(https://leetcode-cn.com/problems/remove-linked-list-elements)"></a>removeElements(<a href="https://leetcode-cn.com/problems/remove-linked-list-elements">https://leetcode-cn.com/problems/remove-linked-list-elements</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。</span></span><br><span class="line"><span class="comment">#  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 1：</span></span><br><span class="line"><span class="comment"># 输入：head = [1,2,6,3,4,5,6], val = 6</span></span><br><span class="line"><span class="comment"># 输出：[1,2,3,4,5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2：</span></span><br><span class="line"><span class="comment"># 输入：head = [], val = 1</span></span><br><span class="line"><span class="comment"># 输出：[]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 3：</span></span><br><span class="line"><span class="comment"># 输入：head = [7,7,7,7], val = 7</span></span><br><span class="line"><span class="comment"># 输出：[]</span></span><br><span class="line"><span class="comment">#  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/remove-linked-list-elements</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeElements</span>(<span class="params">head, val</span>):</span></span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    dummy_head = ListNode(-<span class="number">1</span>)</span><br><span class="line">    dummy_head.<span class="built_in">next</span> = head</span><br><span class="line">    cur = dummy_head</span><br><span class="line">    <span class="keyword">while</span> cur.<span class="built_in">next</span>:</span><br><span class="line">        <span class="keyword">if</span> cur.<span class="built_in">next</span>.val == val:</span><br><span class="line">            cur.<span class="built_in">next</span> = cur.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> dummy_head.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><h4 id="addTwoNumbers-https-leetcode-cn-com-problems-add-two-numbers"><a href="#addTwoNumbers-https-leetcode-cn-com-problems-add-two-numbers" class="headerlink" title="addTwoNumbers(https://leetcode-cn.com/problems/add-two-numbers)"></a>addTwoNumbers(<a href="https://leetcode-cn.com/problems/add-two-numbers">https://leetcode-cn.com/problems/add-two-numbers</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 请你将两个数相加，并以相同形式返回一个表示和的链表。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入：l1 = [2,4,3], l2 = [5,6,4]</span></span><br><span class="line"><span class="comment"># 输出：[7,0,8]</span></span><br><span class="line"><span class="comment"># 解释：342 + 465 = 807.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2：</span></span><br><span class="line"><span class="comment"># 输入：l1 = [0], l2 = [0]</span></span><br><span class="line"><span class="comment"># 输出：[0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 3：</span></span><br><span class="line"><span class="comment"># 输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]</span></span><br><span class="line"><span class="comment"># 输出：[8,9,9,9,0,0,0,1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/add-two-numbers</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val=<span class="number">0</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 思路:用一个变量存储每次进取的1，然后两链表的值依次相加，如果有一个先先结束，那么另外一个就继续加进取的1，直到加完，最后判断一下最后是不是还有进取的1，如果有就加到最后</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span>(<span class="params">l1, l2</span>):</span></span><br><span class="line">    dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    next1 = <span class="number">0</span></span><br><span class="line">    cur = dummy</span><br><span class="line">    <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">        total = l1.val + l2.val + next1</span><br><span class="line">        cur.<span class="built_in">next</span> = ListNode(total % <span class="number">10</span>)</span><br><span class="line">        next1 = total // <span class="number">10</span></span><br><span class="line">        cur = cur.<span class="built_in">next</span></span><br><span class="line">        l1 = l1.<span class="built_in">next</span></span><br><span class="line">        l2 = l2.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> l1:</span><br><span class="line">        total = l1.val + next1</span><br><span class="line">        cur.<span class="built_in">next</span> = ListNode(total % <span class="number">10</span>)</span><br><span class="line">        next1 = total // <span class="number">10</span></span><br><span class="line">        cur = cur.<span class="built_in">next</span></span><br><span class="line">        l1 = l1.<span class="built_in">next</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> l2:</span><br><span class="line">        total = l2.val + next1</span><br><span class="line">        cur.<span class="built_in">next</span> = ListNode(total % <span class="number">10</span>)</span><br><span class="line">        next1 = total // <span class="number">10</span></span><br><span class="line">        cur = cur.<span class="built_in">next</span></span><br><span class="line">        l2 = l2.<span class="built_in">next</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> next1 != <span class="number">0</span>:</span><br><span class="line">        cur.<span class="built_in">next</span> = ListNode(next1)</span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="reverseKGroup-https-leetcode-cn-com-problems-reverse-nodes-in-k-group"><a href="#reverseKGroup-https-leetcode-cn-com-problems-reverse-nodes-in-k-group" class="headerlink" title="reverseKGroup(https://leetcode-cn.com/problems/reverse-nodes-in-k-group)"></a>reverseKGroup(<a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group">https://leetcode-cn.com/problems/reverse-nodes-in-k-group</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># k 是一个正整数，它的值小于或等于链表的长度。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进阶：</span></span><br><span class="line"><span class="comment"># 你可以设计一个只使用常数额外空间的算法来解决此问题吗？</span></span><br><span class="line"><span class="comment"># 你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 1：</span></span><br><span class="line"><span class="comment"># 输入：head = [1,2,3,4,5], k = 2</span></span><br><span class="line"><span class="comment"># 输出：[2,1,4,3,5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2：</span></span><br><span class="line"><span class="comment"># 输入：head = [1,2,3,4,5], k = 3</span></span><br><span class="line"><span class="comment"># 输出：[3,2,1,4,5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 3：</span></span><br><span class="line"><span class="comment"># 输入：head = [1,2,3,4,5], k = 1</span></span><br><span class="line"><span class="comment"># 输出：[1,2,3,4,5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 4：</span></span><br><span class="line"><span class="comment"># 输入：head = [1], k = 1</span></span><br><span class="line"><span class="comment"># 输出：[1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/reverse-nodes-in-k-group</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, val=<span class="number">0</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">head</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    <span class="comment"># dummy = ListNode(-1)</span></span><br><span class="line">    pre = <span class="literal">None</span></span><br><span class="line">    <span class="comment"># dummy.next = head</span></span><br><span class="line">    cur = head</span><br><span class="line">    nex = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        nex = cur.<span class="built_in">next</span></span><br><span class="line">        cur.<span class="built_in">next</span> = pre</span><br><span class="line">        pre = cur</span><br><span class="line">        cur = nex</span><br><span class="line">    <span class="keyword">return</span> pre</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseKGroup</span>(<span class="params">head, k</span>):</span></span><br><span class="line">    <span class="comment"># 求出链表的长度</span></span><br><span class="line">    count_head = head</span><br><span class="line">    len_list = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> count_head:</span><br><span class="line">        len_list += <span class="number">1</span></span><br><span class="line">        count_head = count_head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> k &lt;= <span class="number">0</span> <span class="keyword">or</span> k &gt; len_list <span class="keyword">or</span> head == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    dummy = ListNode(-<span class="number">1</span>)</span><br><span class="line">    dummy.<span class="built_in">next</span> = head</span><br><span class="line">    pre = dummy</span><br><span class="line">    start = head</span><br><span class="line">    end = head</span><br><span class="line">    nex = head</span><br><span class="line">    <span class="keyword">while</span> nex:</span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; k <span class="keyword">and</span> end <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            end = end.<span class="built_in">next</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 如果链表的尾部没有被K整除，则跳出循环</span></span><br><span class="line">        <span class="keyword">if</span> end == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 反转【start...end】区间的链表</span></span><br><span class="line">        nex = end.<span class="built_in">next</span></span><br><span class="line">        end.<span class="built_in">next</span> = <span class="literal">None</span> <span class="comment"># 断开链表，翻转区间和待反转区间</span></span><br><span class="line">        end = start</span><br><span class="line">        start = reverseList(start)</span><br><span class="line">        <span class="comment"># 反转完拼接回来</span></span><br><span class="line">        end.<span class="built_in">next</span> = nex</span><br><span class="line">        pre.<span class="built_in">next</span> = start</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 重新调整pre start end nex 指针</span></span><br><span class="line">        pre = end</span><br><span class="line">        start = nex</span><br><span class="line">        end = start</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># head = ListNode(1)</span></span><br><span class="line"><span class="comment"># head.next = ListNode(2)</span></span><br><span class="line"><span class="comment"># head.next.next = ListNode(3)</span></span><br><span class="line"><span class="comment"># head.next.next.next = ListNode(4)</span></span><br><span class="line"><span class="comment"># head.next.next.next.next = ListNode(5)</span></span><br><span class="line"><span class="comment"># # head.next.next.next.next.next = ListNode(6)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># res = reverseKGroup(head, 3)</span></span><br><span class="line"><span class="comment"># while res:</span></span><br><span class="line"><span class="comment">#     print (res.val)</span></span><br><span class="line"><span class="comment">#     res = res.next</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h4 id=&quot;reverseList-https-leetcode-cn-com-problems-fan-zhuan-lian-biao-lcof&quot;&gt;&lt;a href=&quot;#reverseList-https-leetcode-cn-com-proble</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数组相关</title>
    <link href="http://example.com/2021/06/01/%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3/"/>
    <id>http://example.com/2021/06/01/%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3/</id>
    <published>2021-06-01T13:48:45.000Z</published>
    <updated>2021-06-13T07:57:42.855Z</updated>
    
    <content type="html"><![CDATA[<h4 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h4><h5 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_search</span>(<span class="params">array</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(array)-<span class="number">1</span>):</span><br><span class="line">        smallest_index = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, <span class="built_in">len</span>(array)):</span><br><span class="line">            <span class="keyword">if</span> array[j] &lt; array[smallest_index]:</span><br><span class="line">                smallest_index = j</span><br><span class="line">        <span class="keyword">if</span> i != smallest_index:</span><br><span class="line">            array[i],array[smallest_index] = array[smallest_index], array[i]</span><br><span class="line">    <span class="keyword">return</span> array</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">array = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(select_search(array))</span><br><span class="line">            </span><br></pre></td></tr></table></figure><h5 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_search</span>(<span class="params">array</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(array)-<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(array)-<span class="number">1</span>-i):</span><br><span class="line">            <span class="keyword">if</span> array[j] &gt; array[j+<span class="number">1</span>]:</span><br><span class="line">                array[j], array[j+<span class="number">1</span>] = array[j+<span class="number">1</span>], array[j]</span><br><span class="line">    <span class="keyword">return</span> array</span><br><span class="line"></span><br><span class="line">array = [<span class="number">1</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">10</span>]</span><br><span class="line"><span class="built_in">print</span>(bubble_search(array))</span><br></pre></td></tr></table></figure><h5 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 快速排序，分而治之+递归的思想</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span>(<span class="params">nums, left, right</span>):</span></span><br><span class="line">    <span class="keyword">if</span> left &lt; right:</span><br><span class="line">        mid = get_mid1(nums, left, right)</span><br><span class="line">        quick_sort(nums, left, mid-<span class="number">1</span>)</span><br><span class="line">        quick_sort(nums, mid+<span class="number">1</span>, right)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从小到大</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_mid</span>(<span class="params">nums,left,right</span>):</span></span><br><span class="line">    privot = nums[left]</span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[right] &gt;= privot:</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        nums[left] = nums[right]</span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left] &lt; privot:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        nums[right] = nums[left]</span><br><span class="line">    <span class="keyword">if</span> right &lt;= left:</span><br><span class="line">        nums[left] = privot</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从大到小</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_mid1</span>(<span class="params">nums,left,right</span>):</span></span><br><span class="line">    privot = nums[right]</span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left] &gt;= privot:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        nums[right] = nums[left]</span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[right] &lt; privot:</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        nums[left] = nums[right]</span><br><span class="line">    <span class="keyword">if</span> right &lt;= left:</span><br><span class="line">        nums[left] = privot</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nums = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">77</span>,<span class="number">0</span>,<span class="number">23</span>]</span><br><span class="line">quick_sort(nums,<span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(nums)</span><br></pre></td></tr></table></figure><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每次比较中间的数，若目标数大于中间数，则去右区间查找，反之去左区间查找，并且依次缩小区间，直到跳出循环</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span>(<span class="params">array, target</span>):</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = <span class="built_in">len</span>(array)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        mid = left + (right - left) / <span class="number">2</span> <span class="comment"># 防止整形溢出</span></span><br><span class="line">        <span class="keyword">if</span> target == array[mid]:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">if</span> target &gt; array[mid]:</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid -<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="moveZero（https-leetcode-cn-com-problems-move-zeroes）"><a href="#moveZero（https-leetcode-cn-com-problems-move-zeroes）" class="headerlink" title="moveZero（https://leetcode-cn.com/problems/move-zeroes）"></a>moveZero（<a href="https://leetcode-cn.com/problems/move-zeroes%EF%BC%89">https://leetcode-cn.com/problems/move-zeroes）</a></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入: [0,1,0,3,12]</span></span><br><span class="line"><span class="comment"># 输出: [1,3,12,0,0]</span></span><br><span class="line"><span class="comment"># 说明:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 必须在原数组上操作，不能拷贝额外的数组。</span></span><br><span class="line"><span class="comment"># 尽量减少操作次数。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 先对整个数组进行非零扫描，然后空出来的末尾用0补充  list.remove(0)该方法没有返回值但是会移除列表中的某个值的第一个匹配项。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># def moveZeroes1(nums):</span></span><br><span class="line"><span class="comment">#     l = len(nums)</span></span><br><span class="line"><span class="comment">#     while True:</span></span><br><span class="line"><span class="comment">#         try:</span></span><br><span class="line"><span class="comment">#             nums.remove(0)</span></span><br><span class="line"><span class="comment">#         except Exception:</span></span><br><span class="line"><span class="comment">#             break</span></span><br><span class="line"><span class="comment">#     nums = nums + [0]*(l-len(nums))</span></span><br><span class="line"><span class="comment">#     return nums</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># # 双指针的方式 [0..k) 记录非0的位置</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">situation</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moveZeroes2</span>(<span class="params">self,nums</span>):</span></span><br><span class="line">        k = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i]: <span class="comment"># 记录所有非零的元素</span></span><br><span class="line">                <span class="keyword">if</span> i != k:  <span class="comment"># 考虑到数组全为0的情况</span></span><br><span class="line">                    nums[k] , nums[i] = nums[i] , nums[k]</span><br><span class="line">                    k = k + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    k = k + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="removeDuplicates-https-leetcode-cn-com-problems-remove-duplicates-from-sorted-array"><a href="#removeDuplicates-https-leetcode-cn-com-problems-remove-duplicates-from-sorted-array" class="headerlink" title="removeDuplicates(https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array)"></a>removeDuplicates(<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。</span></span><br><span class="line"><span class="comment"># 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入：nums = [1,1,2]</span></span><br><span class="line"><span class="comment"># 输出：2, nums = [1,2]</span></span><br><span class="line"><span class="comment"># 解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 双指针思路（https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/solution/shu-ju-jie-gou-he-suan-fa-shuang-zhi-zhe-12s1/）</span></span><br><span class="line"><span class="comment"># 大致就是一个前指针，一个后指针，当后指针指向的值和前置机指向的值不相等的时候，前指针向前滑动一下，并且把后指针的值赋值给前指针，最后返回前置机的位置+1便是整个数组的长度</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span>(<span class="params">nums</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> right <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[right] != nums[left]:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            nums[left] = nums[right]</span><br><span class="line">    <span class="keyword">return</span> left+<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span>(removeDuplicates(num))</span><br></pre></td></tr></table></figure><h4 id="removeElement-https-leetcode-cn-com-problems-remove-element"><a href="#removeElement-https-leetcode-cn-com-problems-remove-element" class="headerlink" title="removeElement(https://leetcode-cn.com/problems/remove-element)"></a>removeElement(<a href="https://leetcode-cn.com/problems/remove-element">https://leetcode-cn.com/problems/remove-element</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</span></span><br><span class="line"><span class="comment"># 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</span></span><br><span class="line"><span class="comment"># 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素</span></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/remove-element</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例:</span></span><br><span class="line"><span class="comment"># 输入：nums = [3,2,2,3], val = 3</span></span><br><span class="line"><span class="comment"># 输出：2, nums = [2,2]</span></span><br><span class="line"><span class="comment"># 解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 思路:双指针思路，分前后指针，前指针从零开始，后指针从末尾往前滑动，当前指针指向的数和目标数相等时，把后指针的值赋值给前指针，并且后指针--，直到条件结束</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">removeElement</span>(<span class="params">nums, val</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    right = <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        <span class="keyword">if</span> nums[left] == val:</span><br><span class="line">            nums[left] = nums[right]</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> nums[<span class="number">0</span>:left]</span><br><span class="line"></span><br><span class="line">nums = [<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(removeElement(nums, <span class="number">2</span>))</span><br></pre></td></tr></table></figure><h4 id="sortColors-https-leetcode-cn-com-problems-sort-colors"><a href="#sortColors-https-leetcode-cn-com-problems-sort-colors" class="headerlink" title="sortColors(https://leetcode-cn.com/problems/sort-colors)"></a>sortColors(<a href="https://leetcode-cn.com/problems/sort-colors">https://leetcode-cn.com/problems/sort-colors</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</span></span><br><span class="line"><span class="comment"># 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</span></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/sort-colors</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 1：</span></span><br><span class="line"><span class="comment"># 输入：nums = [2,0,2,1,1,0]</span></span><br><span class="line"><span class="comment"># 输出：[0,0,1,1,2,2]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 思路一:暴力排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortColors1</span>(<span class="params">nums</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">    count = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        count[nums[i]] += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(count[i]):</span><br><span class="line">            nums[index] = i</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 每次维护[0..left]都是为0，[left+1...right-1]都是为1，[right...len(nums)-1]都是2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortColors2</span>(<span class="params">nums</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    left = -<span class="number">1</span> <span class="comment">#[0...left] = 0</span></span><br><span class="line">    right = <span class="built_in">len</span>(nums) <span class="comment">#[right...len(num)-1] = 2</span></span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; right:</span><br><span class="line">        <span class="keyword">if</span> nums[i] == <span class="number">2</span>:</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">            nums[i], nums[right] = nums[right], nums[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> nums[i] == <span class="number">0</span>:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            nums[i], nums[left] = nums[left], nums[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure><h4 id="mergeSortedArray-https-leetcode-cn-com-problems-merge-sorted-array"><a href="#mergeSortedArray-https-leetcode-cn-com-problems-merge-sorted-array" class="headerlink" title="mergeSortedArray(https://leetcode-cn.com/problems/merge-sorted-array/)"></a>mergeSortedArray(<a href="https://leetcode-cn.com/problems/merge-sorted-array/">https://leetcode-cn.com/problems/merge-sorted-array/</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。</span></span><br><span class="line"><span class="comment"># 初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间大小等于 m + n，这样它就有足够的空间保存来自 nums2 的元素。</span></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/merge-sorted-array</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#示例 1：</span></span><br><span class="line"><span class="comment">#输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3</span></span><br><span class="line"><span class="comment">#输出：[1,2,2,3,5,6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴力破解</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge1</span>(<span class="params">nums1, nums2</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums1) &lt;= <span class="number">0</span> <span class="keyword">or</span> <span class="built_in">len</span>(nums2) &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="comment"># 先合并再排序</span></span><br><span class="line">    nums = nums1+nums2</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sorted</span>(nums)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 双指针解法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge2</span>(<span class="params">nums1, m, nums2, n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums1) &lt;= <span class="number">0</span> <span class="keyword">or</span> <span class="built_in">len</span>(nums2)&lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    left , right, index = m-<span class="number">1</span>, n-<span class="number">1</span>, <span class="built_in">len</span>(nums1)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &gt;= <span class="number">0</span> <span class="keyword">and</span> right&gt;=<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> nums1[left] &gt;= nums2[right]:</span><br><span class="line">            nums1[index] = nums1[left]</span><br><span class="line">            left -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            nums1[index] = nums2[right]</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        index -= <span class="number">1</span></span><br><span class="line">        <span class="comment"># 如果num2还么有遍历完则继续</span></span><br><span class="line">        <span class="keyword">while</span> right &gt;= <span class="number">0</span>:</span><br><span class="line">            nums1[index] = nums2[right]</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">            index -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> nums1</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="findKthLargest-https-leetcode-cn-com-problems-kth-largest-element-in-an-array"><a href="#findKthLargest-https-leetcode-cn-com-problems-kth-largest-element-in-an-array" class="headerlink" title="findKthLargest(https://leetcode-cn.com/problems/kth-largest-element-in-an-array)"></a>findKthLargest(<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array">https://leetcode-cn.com/problems/kth-largest-element-in-an-array</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 1:</span></span><br><span class="line"><span class="comment"># 输入: [3,2,1,5,6,4] 和 k = 2</span></span><br><span class="line"><span class="comment"># 输出: 5</span></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/kth-largest-element-in-an-array</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.暴力破解</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findKthLargest1</span>(<span class="params">nums, k</span>):</span></span><br><span class="line">    <span class="keyword">if</span> k&lt;<span class="number">0</span> <span class="keyword">or</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    n = <span class="built_in">sorted</span>(nums)</span><br><span class="line">    <span class="keyword">return</span> n[-k]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.堆排序。每次维护一个K个大小的堆，每次pop堆中最小的那个数，直到最后整个堆便是前K个大的数</span></span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findKthLargest2</span>(<span class="params">nums, k</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;=<span class="number">0</span> <span class="keyword">or</span> k &lt;=<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    heap = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        heapq.heappush(heap, <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>))</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        heapq.heappush(heap, nums[k])</span><br><span class="line">        heapq.heappop(heap)</span><br><span class="line">    <span class="keyword">return</span> heap[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.快排的双指针思想</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findKthLargest3</span>(<span class="params">nums, k</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">0</span> <span class="keyword">or</span> k &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> quick_sort(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span>, k)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span>(<span class="params">nums, left, right, k</span>):</span></span><br><span class="line">    index = random_partition(nums, left, right)</span><br><span class="line">    <span class="keyword">if</span> index == k-<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nums[index]</span><br><span class="line">    <span class="keyword">elif</span> index &gt; k-<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> quick_sort(nums, left, index-<span class="number">1</span>, k)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> quick_sort(nums, index+<span class="number">1</span>, right, k)</span><br><span class="line">       </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_partition</span>(<span class="params">nums, left, right</span>):</span></span><br><span class="line">    i = random.randint(left, right)</span><br><span class="line">    nums[i], nums[right] = nums[right], nums[i]</span><br><span class="line">    <span class="keyword">return</span> get_parition(nums, left, right)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_parition</span>(<span class="params">nums, left, right</span>):</span></span><br><span class="line">    privot = nums[right]</span><br><span class="line">    right_most = right</span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left] &gt; privot:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        nums[right] = nums[left]</span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[right] &lt;= privot:</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        nums[left] = nums[right]</span><br><span class="line">    <span class="keyword">if</span> left &gt;= right:</span><br><span class="line">        <span class="comment"># nums[left], nums[right_most]= nums[right_most], nums[left]</span></span><br><span class="line">        nums[left] = privot</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line"></span><br><span class="line">nums = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line">res = findKthLargest3(nums, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure><h4 id="two-sumi-https-leetcode-cn-com-problems-two-sum"><a href="#two-sumi-https-leetcode-cn-com-problems-two-sum" class="headerlink" title="two_sumi(https://leetcode-cn.com/problems/two-sum/)"></a>two_sumi(<a href="https://leetcode-cn.com/problems/two-sum/">https://leetcode-cn.com/problems/two-sum/</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</span></span><br><span class="line"><span class="comment"># 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</span></span><br><span class="line"><span class="comment"># 你可以按任意顺序返回答案</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 1：</span></span><br><span class="line"><span class="comment"># 输入：nums = [2,7,11,15], target = 9</span></span><br><span class="line"><span class="comment"># 输出：[0,1]</span></span><br><span class="line"><span class="comment"># 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2：</span></span><br><span class="line"><span class="comment"># 输入：nums = [3,2,4], target = 6</span></span><br><span class="line"><span class="comment"># 输出：[1,2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># https://leetcode-cn.com/problems/two-sum/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 借助散列表这种O(1时间复杂度的数据结构)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">two_sum</span>(<span class="params">nums, target</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    nums_map = <span class="built_in">dict</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        another_num = target - nums[i]</span><br><span class="line">        <span class="keyword">if</span> another_num <span class="keyword">not</span> <span class="keyword">in</span> nums_map:</span><br><span class="line">            nums_map[nums[i]] = i</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> [i, nums_map[another_num]]</span><br><span class="line">    <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure><h4 id="two-sum-ii-https-leetcode-cn-com-problems-two-sum-ii-input-array-is-sorted"><a href="#two-sum-ii-https-leetcode-cn-com-problems-two-sum-ii-input-array-is-sorted" class="headerlink" title="two_sum_ii(https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted)"></a>two_sum_ii(<a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted">https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给定一个已按照 升序排列  的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。</span></span><br><span class="line"><span class="comment"># 函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 1 开始计数 ，所以答案数组应当满足 1 &lt;= answer[0] &lt; answer[1] &lt;= numbers.length 。</span></span><br><span class="line"><span class="comment"># 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 1：</span></span><br><span class="line"><span class="comment"># 输入：numbers = [2,7,11,15], target = 9</span></span><br><span class="line"><span class="comment"># 输出：[1,2]</span></span><br><span class="line"><span class="comment"># 解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#1.暴力破解法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">two_sum1</span>(<span class="params">nums, target</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> target-nums[i] == nums[j]:</span><br><span class="line">                <span class="keyword">return</span> [i+<span class="number">1</span>, j+<span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.因为该数组是一个有序的数组，所以我们可以充分利用这一点用二分查找的思想去解决</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">two_sum2</span>(<span class="params">nums, target</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        n = target - nums[i]</span><br><span class="line">        j = binary_search(nums, n)</span><br><span class="line">        <span class="keyword">if</span> j &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> [i+<span class="number">1</span>, j+<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span>(<span class="params">nums, n</span>):</span></span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">    mid = <span class="built_in">int</span>(left + (right - left)/<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        <span class="keyword">if</span> n == nums[mid]:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> n &gt; nums[mid]:</span><br><span class="line">            left = mid +<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right = mid -<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.双指针思想:一个从前往后滑动，一个从后往前滑动，如果两边的和大于target，右指针往前滑，反之左指针往后滑</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">two_sum3</span>(<span class="params">nums, target</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;=  <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">        <span class="keyword">if</span> nums[left]+nums[right] == target:</span><br><span class="line">            <span class="keyword">return</span> [left+<span class="number">1</span>,right+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">elif</span> nums[left]+nums[right] &gt; target:</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>]</span><br><span class="line">target = <span class="number">9</span></span><br><span class="line"><span class="built_in">print</span>(two_sum3(nums, target))</span><br></pre></td></tr></table></figure><h4 id="threeSum-https-leetcode-cn-com-problems-3sum"><a href="#threeSum-https-leetcode-cn-com-problems-3sum" class="headerlink" title="threeSum(https://leetcode-cn.com/problems/3sum/)"></a>threeSum(<a href="https://leetcode-cn.com/problems/3sum/">https://leetcode-cn.com/problems/3sum/</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</span></span><br><span class="line"><span class="comment"># 注意：答案中不可以包含重复的三元组。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 1：</span></span><br><span class="line"><span class="comment"># 输入：nums = [-1,0,1,2,-1,-4]</span></span><br><span class="line"><span class="comment"># 输出：[[-1,-1,2],[-1,0,1]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2：</span></span><br><span class="line"><span class="comment"># 输入：nums = []</span></span><br><span class="line"><span class="comment"># 输出：[]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 3：</span></span><br><span class="line"><span class="comment"># 输入：nums = [0]</span></span><br><span class="line"><span class="comment"># 输出：[]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/3sum</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">three_sum</span>(<span class="params">nums</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    res = []</span><br><span class="line">    <span class="comment"># 先排序</span></span><br><span class="line">    nums = <span class="built_in">sorted</span>(nums)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        left, right = i+<span class="number">1</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            <span class="keyword">if</span> nums[i]+nums[left]+nums[right] == <span class="number">0</span>:</span><br><span class="line">                res.append([nums[i], nums[left], nums[right]])</span><br><span class="line">                <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left] == nums[left+<span class="number">1</span>]:  <span class="comment">#去重处理</span></span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[right] == nums[right-<span class="number">1</span>]:</span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[i]+nums[left]+nums[right] &lt; <span class="number">0</span>:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="fourSumCount-https-leetcode-cn-com-problems-4sum-ii"><a href="#fourSumCount-https-leetcode-cn-com-problems-4sum-ii" class="headerlink" title="fourSumCount(https://leetcode-cn.com/problems/4sum-ii)"></a>fourSumCount(<a href="https://leetcode-cn.com/problems/4sum-ii">https://leetcode-cn.com/problems/4sum-ii</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。</span></span><br><span class="line"><span class="comment"># 为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -228 到 228 - 1 之间，最终结果不会超过 231 - 1 。</span></span><br><span class="line"><span class="comment"># 例如:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入:</span></span><br><span class="line"><span class="comment"># A = [ 1, 2]</span></span><br><span class="line"><span class="comment"># B = [-2,-1]</span></span><br><span class="line"><span class="comment"># C = [-1, 2]</span></span><br><span class="line"><span class="comment"># D = [ 0, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解释:</span></span><br><span class="line"><span class="comment"># 两个元组如下:</span></span><br><span class="line"><span class="comment"># 1. (0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0</span></span><br><span class="line"><span class="comment"># 2. (1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/4sum-ii</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fourSumCount</span>(<span class="params">nums1, nums2, nums3, nums4</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums1) &lt;=<span class="number">0</span> <span class="keyword">or</span> <span class="built_in">len</span>(nums2)&lt;=<span class="number">0</span> <span class="keyword">or</span> <span class="built_in">len</span>(nums3)&lt;=<span class="number">0</span> <span class="keyword">or</span> <span class="built_in">len</span>(nums4)&lt;=<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 先计算nums1[i]和nums[i]的和，存进map中</span></span><br><span class="line">    num_map = &#123;&#125;</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums1)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums2)):</span><br><span class="line">            num_map[nums1[i]+nums2[j]] = num_map.get(nums1[i]+nums2[j], <span class="number">0</span>)+<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 在看nums3[i]+nums4[j]的和</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums3)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums4)):</span><br><span class="line">            s = -(nums3[i] + nums4[j])</span><br><span class="line">            <span class="keyword">if</span> s <span class="keyword">in</span> num_map:</span><br><span class="line">                res += num_map[s]</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="isPalindrome-https-leetcode-cn-com-problems-valid-palindrome"><a href="#isPalindrome-https-leetcode-cn-com-problems-valid-palindrome" class="headerlink" title="isPalindrome(https://leetcode-cn.com/problems/valid-palindrome/)"></a>isPalindrome(<a href="https://leetcode-cn.com/problems/valid-palindrome/">https://leetcode-cn.com/problems/valid-palindrome/</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</span></span><br><span class="line"><span class="comment"># 说明：本题中，我们将空字符串定义为有效的回文串。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 1:</span></span><br><span class="line"><span class="comment"># 输入: &quot;A man, a plan, a canal: Panama&quot;</span></span><br><span class="line"><span class="comment"># 输出: true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2:</span></span><br><span class="line"><span class="comment"># 输入: &quot;race a car&quot;</span></span><br><span class="line"><span class="comment"># 输出: false</span></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/valid-palindrome</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">s</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    s1 = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">        <span class="keyword">if</span> ((s[i] &gt;= <span class="string">&#x27;a&#x27;</span> <span class="keyword">and</span> s[i] &lt;=<span class="string">&#x27;z&#x27;</span>) <span class="keyword">or</span> (s[i] &gt;=<span class="string">&#x27;A&#x27;</span> <span class="keyword">and</span> s[i] &lt;= <span class="string">&#x27;Z&#x27;</span>) <span class="keyword">or</span> (s[i] &gt;= <span class="string">&#x27;0&#x27;</span> <span class="keyword">and</span> s[i] &lt;=<span class="string">&#x27;9&#x27;</span>)):</span><br><span class="line">            s1.append(s[i])</span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(s1)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s1) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        <span class="keyword">if</span> s1[left].lower() == s1[right].lower():</span><br><span class="line">            <span class="comment"># return isPalindrome(s[left+1:right-1])</span></span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">s = <span class="string">&quot;ab_a&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">0</span>] == s[<span class="built_in">len</span>(s) -<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(isPalindrome(s))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="maxArea-https-leetcode-cn-com-problems-container-with-most-water"><a href="#maxArea-https-leetcode-cn-com-problems-container-with-most-water" class="headerlink" title="maxArea(https://leetcode-cn.com/problems/container-with-most-water)"></a>maxArea(<a href="https://leetcode-cn.com/problems/container-with-most-water">https://leetcode-cn.com/problems/container-with-most-water</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。</span></span><br><span class="line"><span class="comment"># 在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。</span></span><br><span class="line"><span class="comment"># 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</span></span><br><span class="line"><span class="comment"># 说明：你不能倾斜容器。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/container-with-most-water</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 面积取决于短板。</span></span><br><span class="line"><span class="comment"># 1.因此即使长板往内移动时遇到更长的板，矩形的面积也不会改变；遇到更短的板时，面积会变小。</span></span><br><span class="line"><span class="comment"># 2.因此想要面积变大，只能让短板往内移动(因为移动方向固定了)，当然也有可能让面积变得更小，但只有这样才存在让面积变大的可能性</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 因此双指针的思路解决这道题目:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxArea1</span>(<span class="params">height</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(height) &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    maxV = -<span class="number">1</span></span><br><span class="line">    left, right = <span class="number">0</span>, <span class="built_in">len</span>(height)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        <span class="keyword">if</span> height[left] &lt; height[right]:</span><br><span class="line">            maxV = <span class="built_in">max</span>(maxV, height[left]*(right-left))</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            maxV = <span class="built_in">max</span>(maxV, height[right]*(right-left))</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> maxV</span><br><span class="line"></span><br><span class="line">height = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">18</span>,<span class="number">17</span>,<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">res = maxArea1(height)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="minSubArrayLen-https-leetcode-cn-com-problems-minimum-size-subarray-sum"><a href="#minSubArrayLen-https-leetcode-cn-com-problems-minimum-size-subarray-sum" class="headerlink" title="minSubArrayLen(https://leetcode-cn.com/problems/minimum-size-subarray-sum)"></a>minSubArrayLen(<a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum">https://leetcode-cn.com/problems/minimum-size-subarray-sum</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给定一个含有 n 个正整数的数组和一个正整数 target 。</span></span><br><span class="line"><span class="comment"># 找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 1：</span></span><br><span class="line"><span class="comment"># 输入：target = 7, nums = [2,3,1,2,4,3]</span></span><br><span class="line"><span class="comment"># 输出：2</span></span><br><span class="line"><span class="comment"># 解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2：</span></span><br><span class="line"><span class="comment"># 输入：target = 4, nums = [1,4,4]</span></span><br><span class="line"><span class="comment"># 输出：1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/minimum-size-subarray-sum</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.暴力破解法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minSubArrayLen1</span>(<span class="params">s, nums</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    minlen = <span class="built_in">len</span>(nums)+<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, <span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="built_in">sum</span> += nums[j]</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span> &gt;= s:</span><br><span class="line">                minlen = <span class="built_in">min</span>(minlen, j-i+<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> minlen == <span class="built_in">len</span>(nums)+<span class="number">1</span> <span class="keyword">else</span> minlen</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.双指针算法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minSubArrayLen2</span>(<span class="params">s, nums</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    left, right = <span class="number">0</span> , -<span class="number">1</span></span><br><span class="line">    min_len = <span class="built_in">len</span>(nums)+<span class="number">1</span></span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sum</span> &lt; s) <span class="keyword">and</span> (right &lt; <span class="built_in">len</span>(nums)-<span class="number">1</span>): <span class="comment"># 小了的话就把这个窗口往右滑动</span></span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">            <span class="built_in">sum</span> += nums[right]</span><br><span class="line">        <span class="keyword">else</span>:                                  <span class="comment"># 大了就把这个窗口往左边滑动</span></span><br><span class="line">            <span class="built_in">sum</span> -= nums[left]</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">sum</span> &gt;= s:</span><br><span class="line">            min_len = <span class="built_in">min</span>(min_len, right-left+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> min_len==<span class="built_in">len</span>(nums)+<span class="number">1</span> <span class="keyword">else</span> min_len</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">nums = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br><span class="line">target = <span class="number">7</span></span><br><span class="line"><span class="built_in">print</span>(minSubArrayLen2(target, nums))                </span><br></pre></td></tr></table></figure><h4 id="lengthOfLongestSubstring-https-leetcode-cn-com-problems-zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof"><a href="#lengthOfLongestSubstring-https-leetcode-cn-com-problems-zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof" class="headerlink" title="lengthOfLongestSubstring(https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/)"></a>lengthOfLongestSubstring(<a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</span></span><br><span class="line"><span class="comment"># 示例 1:</span></span><br><span class="line"><span class="comment"># 输入: s = &quot;abcabcbb&quot;</span></span><br><span class="line"><span class="comment"># 输出: 3 </span></span><br><span class="line"><span class="comment"># 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2:</span></span><br><span class="line"><span class="comment"># 输入: s = &quot;bbbbb&quot;</span></span><br><span class="line"><span class="comment"># 输出: 1</span></span><br><span class="line"><span class="comment"># 解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 滑动窗口的思想,并且用一个一维数组储存每个字母对应的ascill码出现的频率                      </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">s</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    left, right = <span class="number">0</span>, -<span class="number">1</span> <span class="comment">#[left...right]区间的滑动窗口</span></span><br><span class="line">    max_len = <span class="number">0</span></span><br><span class="line">    freq = [<span class="number">0</span>]*<span class="number">256</span></span><br><span class="line">    <span class="keyword">while</span> left &lt; <span class="built_in">len</span>(s):</span><br><span class="line">        <span class="keyword">if</span> right+<span class="number">1</span> &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> freq[<span class="built_in">ord</span>(s[right+<span class="number">1</span>])] == <span class="number">0</span>:</span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">            freq[<span class="built_in">ord</span>(s[right])] += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            freq[<span class="built_in">ord</span>(s[left])] -= <span class="number">1</span></span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        max_len = <span class="built_in">max</span>(max_len, right-left+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> max_len </span><br><span class="line"></span><br><span class="line">s = <span class="string">&quot;pwwkew&quot;</span></span><br><span class="line"><span class="built_in">print</span>(lengthOfLongestSubstring(s))</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="isHappy-https-leetcode-cn-com-problems-happy-number"><a href="#isHappy-https-leetcode-cn-com-problems-happy-number" class="headerlink" title="isHappy(https://leetcode-cn.com/problems/happy-number)"></a>isHappy(<a href="https://leetcode-cn.com/problems/happy-number">https://leetcode-cn.com/problems/happy-number</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编写一个算法来判断一个数 n 是不是快乐数。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 「快乐数」定义为：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</span></span><br><span class="line"><span class="comment"># 然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。</span></span><br><span class="line"><span class="comment"># 如果 可以变为  1，那么这个数就是快乐数。</span></span><br><span class="line"><span class="comment"># 如果 n 是快乐数就返回 true ；不是，则返回 false 。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 1：</span></span><br><span class="line"><span class="comment"># 输入：19</span></span><br><span class="line"><span class="comment"># 输出：true</span></span><br><span class="line"><span class="comment"># 解释：</span></span><br><span class="line"><span class="comment"># 12 + 92 = 82</span></span><br><span class="line"><span class="comment"># 82 + 22 = 68</span></span><br><span class="line"><span class="comment"># 62 + 82 = 100</span></span><br><span class="line"><span class="comment"># 12 + 02 + 02 = 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2：</span></span><br><span class="line"><span class="comment"># 输入：n = 2</span></span><br><span class="line"><span class="comment"># 输出：false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/happy-number</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.快慢双指针，快的走两步，慢的走一步，如果是一个快乐数，那么快的指针肯定要比慢的指针先到达1，若不是一个快乐数，则慢的指针</span></span><br><span class="line"><span class="comment"># 一定会在某个节点追上快指针</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_square_num</span>(<span class="params">n</span>):</span></span><br><span class="line">    square_sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        square_sum  += (n%<span class="number">10</span>)*(n%<span class="number">10</span>)</span><br><span class="line">        n = n//<span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> square_sum</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isHappy1</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    slow, fast = n, get_square_num(n)</span><br><span class="line">    <span class="keyword">while</span> fast != slow <span class="keyword">and</span> fast!= <span class="number">1</span>:</span><br><span class="line">        slow = get_square_num(slow)</span><br><span class="line">        fast = get_square_num(fast)</span><br><span class="line">        fast = get_square_num(fast)</span><br><span class="line">    <span class="keyword">return</span> fast == <span class="number">1</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.用集合的思路:把每次计算出来的平方和放到一个set集合中，每次把计算值的放进set集合中，每次计算完再去判断是不是已经计算过</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isHappy2</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    s = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">while</span> n != <span class="number">1</span> <span class="keyword">and</span> n <span class="keyword">not</span> <span class="keyword">in</span> s:</span><br><span class="line">        s.add(n)</span><br><span class="line">        n = get_square_num(n)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(isHappy2(<span class="number">19</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="containsNearbyDuplicate-https-leetcode-cn-com-problems-contains-duplicate-ii"><a href="#containsNearbyDuplicate-https-leetcode-cn-com-problems-contains-duplicate-ii" class="headerlink" title="containsNearbyDuplicate(https://leetcode-cn.com/problems/contains-duplicate-ii/)"></a>containsNearbyDuplicate(<a href="https://leetcode-cn.com/problems/contains-duplicate-ii/">https://leetcode-cn.com/problems/contains-duplicate-ii/</a>)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的 绝对值 至多为 k。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 1:</span></span><br><span class="line"><span class="comment"># 输入: nums = [1,2,3,1], k = 3</span></span><br><span class="line"><span class="comment"># 输出: true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 2:</span></span><br><span class="line"><span class="comment"># 输入: nums = [1,0,1,1], k = 1</span></span><br><span class="line"><span class="comment"># 输出: true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例 3:</span></span><br><span class="line"><span class="comment"># 输入: nums = [1,2,3,1,2,3], k = 2</span></span><br><span class="line"><span class="comment"># 输出: false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接：https://leetcode-cn.com/problems/contains-duplicate-ii</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.全局一遍遍历即可，时间复杂度O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">containsNearbyDuplicate1</span>(<span class="params">nums, k</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">0</span> <span class="keyword">or</span> k &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    k_dict = <span class="built_in">dict</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[i] <span class="keyword">in</span> k_dict <span class="keyword">and</span> i-k_dict[nums[i]] &lt;=k:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        k_dict[nums[i]] = i</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.维护一个为K大小的滑动窗口，每次去这个为k大小的滑动窗口中去查找有没有nums[i] == nums[j]      </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">containsNearbyDuplicate2</span>(<span class="params">nums, k</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">0</span> <span class="keyword">or</span> k &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    k_set = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[i] <span class="keyword">in</span> k_set:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        k_set.add(nums[i])</span><br><span class="line">        <span class="comment"># 维护大小为k的滑动窗口</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(k_set) == k+<span class="number">1</span>:</span><br><span class="line">            k_set.remove(nums[i-k])</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;排序算法&quot;&gt;&lt;a href=&quot;#排序算法&quot; class=&quot;headerlink&quot; title=&quot;排序算法&quot;&gt;&lt;/a&gt;排序算法&lt;/h4&gt;&lt;h5 id=&quot;选择排序&quot;&gt;&lt;a href=&quot;#选择排序&quot; class=&quot;headerlink&quot; title=&quot;选择排序&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Kafka</title>
    <link href="http://example.com/2021/05/22/Kafka/"/>
    <id>http://example.com/2021/05/22/Kafka/</id>
    <published>2021-05-22T09:29:03.000Z</published>
    <updated>2021-05-23T15:20:38.151Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Kafka入门篇"><a href="#Kafka入门篇" class="headerlink" title="Kafka入门篇"></a>Kafka入门篇</h4><h5 id="Kafka下载"><a href="#Kafka下载" class="headerlink" title="Kafka下载"></a>Kafka下载</h5><p>可以登录kafka官网进行下载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;kafka.apache.org&#x2F;downloads.html</span><br></pre></td></tr></table></figure><h5 id="kafka的基本概念"><a href="#kafka的基本概念" class="headerlink" title="kafka的基本概念"></a>kafka的基本概念</h5><h6 id="kafka作为一个分布式的流平台，这到底意味着什么"><a href="#kafka作为一个分布式的流平台，这到底意味着什么" class="headerlink" title="kafka作为一个分布式的流平台，这到底意味着什么?"></a>kafka作为一个分布式的流平台，这到底意味着什么?</h6><ul><li><p><strong>我们认为，一个流处理平台意味着三个关键能力</strong></p><ol><li>发布和订阅消息(流)，可靠的获取系统和应用程序之间的数据。</li><li>构建实时流的应用程序，对数据流进行抓换或者反应。</li></ol></li><li><p><strong>首先理解几个概念：</strong></p><ol><li>Kafka作为一个集群运行在一个或者多个服务器上。</li><li>kafka集群存储的消息是以topic为类别记录的。</li><li>每个消息是由一个key，一个value和时间戳构成。</li></ol></li><li><p><strong>kafka有四个核心API:</strong></p><ol><li><p>应用程序使用 <a href="https://www.orchome.com/190">Producer API</a> 发布消息到1个或多个topic（主题）中。</p></li><li><p>应用程序使用 <a href="https://www.orchome.com/200">Consumer API</a> 来订阅一个或多个topic，并处理产生的消息。</p></li><li><p>应用程序使用 <a href="https://www.orchome.com/304">Streams API</a> 充当一个流处理器，从1个或多个topic消费输入流，并生产一个输出流到1个或多个输出topic，有效地将输入流转换到输出流。</p></li><li><p><a href="https://www.orchome.com/455">Connector API</a> 可构建或运行可重用的生产者或消费者，将topic连接到现有的应用程序或数据系统。例如，连接到关系数据库的连接器可以捕获表的每个变更。</p><p><img src="/2021/05/22/Kafka/kafka%E5%9B%9B%E4%B8%AA%E6%A0%B8%E5%BF%83API.png" alt="kafka核心API"></p><ul><li>Client和Server之间的通讯，是通过一条简单、高性能并且和开发语言无关的<a href="/fwd?link=https://kafka.apache.org/protocol.html">TCP协议</a>。并且该协议保持与老版本的兼容。Kafka提供了Java Client（客户端）。除了Java客户端外，还有非常多的<a href="/fwd?link=https://cwiki.apache.org/confluence/display/KAFKA/Clients">其它编程语言的客户端</a>。</li></ul></li></ol></li><li><p><strong>kafa中使用的基本术语:</strong></p><ul><li><h4 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Kafka将消息分门别类，每一类的消息称之为一个主题（Topic）。</span><br></pre></td></tr></table></figure></li><li><h4 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">发布消息的对象称之为主题生产者（Kafka topic producer）</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><h4 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">订阅消息并处理发布的消息的对象称之为主题消费者（consumers）</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><h4 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">已发布的消息保存在一组服务器中，称之为Kafka集群。集群中的每一个服务器都是一个代理（Broker）。 消费者可以订阅一个或多个主题（topic），并从Broker拉数据，从而消费这些已发布的消息。</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>主题和日志(Topic和Log)</strong>:</p><ul><li><p>让我们更深入的了解kafka中的topic。</p></li><li><p>topic是发布的消息的类别名，一个topic可以有零个，一个或者多个消费者订阅该主题的消息。</p></li><li><p>对于每个topic，kafka集群都会维护一个分区的log,就像下图中所示:</p><p><img src="/2021/05/22/Kafka/Kafka%E7%9A%84topic.png" alt="Kafka的topic"></p></li><li><p>每一个分区都是一个顺序的，不可变的消息队列，并且可以持续的添加。分区中的消息都被分了一个序列号，称之为偏移量(offset),在每个分区中此偏移量都是唯一的。</p></li><li><p>Kafka集群保持所有的消息，直到它们过期（无论消息是否被消费）。实际上消费者所持有的仅有的元数据就是这个offset（偏移量），也就是说offset由消费者来控制：正常情况当消费者消费消息的时候，偏移量也线性的的增加。但是实际偏移量由消费者控制，消费者可以将偏移量重置为更早的位置，重新读取消息。可以看到这种设计对消费者来说操作自如，一个消费者的操作不会影响其它消费者对此log的处理。</p><p><img src="/2021/05/22/Kafka/%E6%B6%88%E8%B4%B9topic.png" alt="消费topic"></p></li></ul></li><li><p><strong>分布式</strong></p><ul><li>Log的分区被分布到集群中的多个服务器上。每个服务器处理它分到的分区。 根据配置每个分区还可以复制到其它服务器作为备份容错。 每个分区有一个leader，零或多个follower。Leader处理此分区的所有的读写请求，而follower被动的复制数据。如果leader宕机，其它的一个follower会被推举为新的leader。 一台服务器可能同时是一个分区的leader，另一个分区的follower。 这样可以平衡负载，避免所有的请求都只让一台或者某几台服务器处理。</li></ul></li><li><p><strong>Geo-Replication(异地数据同步技术)</strong></p><ul><li>Kafka MirrorMaker为群集提供<code>geo-replication</code>支持。借助<code>MirrorMaker</code>，消息可以跨多个数据中心或云区域进行复制。 您可以在active/passive场景中用于备份和恢复; 或者在active/passive方案中将数据置于更接近用户的位置，或数据本地化。</li></ul></li><li><p><strong>生产者(Producer)</strong></p><ul><li>生产者往某个Topic上发布消息。生产者也负责选择发布到Topic上的哪一个分区。最简单的方式从分区列表中轮流选择。也可以根据某种算法依照权重选择分区。开发者负责如何选择分区的算法。</li></ul></li><li><p><strong>消费者(Consumers)</strong></p><ul><li><p>通常来讲，消息模型可以分为两种， 队列和发布-订阅式。 队列的处理方式是 一组消费者从服务器读取消息，一条消息只有其中的一个消费者来处理。在发布-订阅模型中，消息被广播给所有的消费者，接收到消息的消费者都可以处理此消息。Kafka为这两种模型提供了单一的消费者抽象模型： 消费者组 （consumer group）。 消费者用一个消费者组名标记自己。 一个发布在Topic上消息被分发给此消费者组中的一个消费者。 假如所有的消费者都在一个组中，那么这就变成了queue模型。 假如所有的消费者都在不同的组中，那么就完全变成了发布-订阅模型。 更通用的， 我们可以创建一些消费者组作为逻辑上的订阅者。每个组包含数目不等的消费者， 一个组内多个消费者可以用来扩展性能和容错。正如下图所示：</p><p><img src="/2021/05/22/Kafka/kafka%E6%B6%88%E8%B4%B9%E6%A8%A1%E5%9E%8B.png" alt="kafka消费模型"></p><p>2个kafka集群托管4个分区（P0-P3），2个消费者组，消费组A有2个消费者实例，消费组B有4个。</p><p>正像传统的消息系统一样，Kafka保证消息的顺序不变。 再详细扯几句。传统的队列模型保持消息，并且保证它们的先后顺序不变。但是， 尽管服务器保证了消息的顺序，消息还是异步的发送给各个消费者，消费者收到消息的先后顺序不能保证了。这也意味着并行消费将不能保证消息的先后顺序。用过传统的消息系统的同学肯定清楚，消息的顺序处理很让人头痛。如果只让一个消费者处理消息，又违背了并行处理的初衷。 在这一点上Kafka做的更好，尽管并没有完全解决上述问题。 Kafka采用了一种分而治之的策略：分区。 因为Topic分区中消息只能由消费者组中的唯一一个消费者处理，所以消息肯定是按照先后顺序进行处理的。但是它也仅仅是保证Topic的一个分区顺序处理，不能保证跨分区的消息先后处理顺序。 所以，如果你想要顺序的处理Topic的所有消息，那就只提供一个分区。</p></li></ul></li><li><p><strong>kafka的保证</strong></p><ul><li>生产者发送到一个特定的Topic的分区上，消息将会按照它们发送的顺序依次加入，也就是说，如果一个消息M1和M2使用相同的producer发送，M1先发送，那么M1将比M2的offset低，并且优先的出现在日志中</li><li>消费者收到的消息也是此顺序。</li><li>如果一个Topic配置了复制因子（replication factor）为N， 那么可以允许N-1服务器宕机而不丢失任何已经提交（committed）的消息。</li></ul></li></ul><h5 id="kafka的应用场景"><a href="#kafka的应用场景" class="headerlink" title="kafka的应用场景"></a>kafka的应用场景</h5><h5 id="快速启动kafka"><a href="#快速启动kafka" class="headerlink" title="快速启动kafka"></a>快速启动kafka</h5><h6 id="kafka的生态系统"><a href="#kafka的生态系统" class="headerlink" title="kafka的生态系统"></a>kafka的生态系统</h6>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;Kafka入门篇&quot;&gt;&lt;a href=&quot;#Kafka入门篇&quot; class=&quot;headerlink&quot; title=&quot;Kafka入门篇&quot;&gt;&lt;/a&gt;Kafka入门篇&lt;/h4&gt;&lt;h5 id=&quot;Kafka下载&quot;&gt;&lt;a href=&quot;#Kafka下载&quot; class=&quot;header</summary>
      
    
    
    
    <category term="中间件" scheme="http://example.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="中间件" scheme="http://example.com/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="http://example.com/2021/04/20/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://example.com/2021/04/20/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2021-04-20T14:01:49.000Z</published>
    <updated>2021-04-24T15:37:50.454Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h4 id="动态规划算法"><a href="#动态规划算法" class="headerlink" title="动态规划算法"></a>动态规划算法</h4><p><strong>定义</strong>:</p><p>动态规划算法是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决。<br>动态规划算法的基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。</p><p>我们可以先以一个简单的斐波那契数列入手，慢慢的理解动态规划的的思想</p><h5 id="斐波那契"><a href="#斐波那契" class="headerlink" title="斐波那契"></a>斐波那契</h5><h6 id="自顶向下的求解方式"><a href="#自顶向下的求解方式" class="headerlink" title="自顶向下的求解方式"></a>自顶向下的求解方式</h6><p>第一种方式:最原始的递归求解方式,存在大量重复计算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n&lt;<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> fib(n-<span class="number">1</span>)+fib(n-<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">t1 = <span class="built_in">int</span>(<span class="built_in">round</span>(time.time() * <span class="number">1000</span>))</span><br><span class="line">res = fib(<span class="number">20</span>)</span><br><span class="line">t2 = <span class="built_in">int</span>(<span class="built_in">round</span>(time.time() * <span class="number">1000</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;the res is &#123;0&#125; use time is &#123;1&#125;&quot;</span>.<span class="built_in">format</span>(res,(t2-t1)))</span><br></pre></td></tr></table></figure><p><img src="/2021/04/20/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E9%87%8D%E5%A4%8D%E8%AE%A1%E7%AE%97.png" alt="重复计算"></p><p>如上图，假如我们计算n=4的时候就重复计算了fib(2)，这还是n=4，如果n更大一些，那么重复计算的节点就更多了，因此我们可以用一个数组来记录每次每个节点计算的值，每次计算前都先去查下这个记录的数组，如果已经计算的话就不需要再次计算了，这样的话能减少重复计算的次数，时间效率上就更高一些。</p><p>第二种方式:记忆搜素优化，用一个数组来来记录每个计算过的值，如果已经计算过了那么就不要再次计算，减少计算次数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="comment"># 用一个数组来记录每个n计算过的值</span></span><br><span class="line">    mem = [-<span class="number">1</span>] * (n+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> mem[n] == -<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> fib(n-<span class="number">1</span>) + fib(n-<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> mem[n]</span><br><span class="line">t1 = <span class="built_in">int</span>(<span class="built_in">round</span>(time.time() * <span class="number">1000</span>))</span><br><span class="line">res = fib(<span class="number">20</span>)</span><br><span class="line">t2 = <span class="built_in">int</span>(<span class="built_in">round</span>(time.time() * <span class="number">1000</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;the res is &#123;0&#125; use time is &#123;1&#125;&quot;</span>.<span class="built_in">format</span>(res,(t2-t1)))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="自下向上的求解算法"><a href="#自下向上的求解算法" class="headerlink" title="自下向上的求解算法"></a>自下向上的求解算法</h6><p>这种算法的思想大致就是由下往上推导计算，这样的话时间复杂度和空间复杂度都要更高效</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    pre = <span class="number">1</span></span><br><span class="line">    pre_pre = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">        res = pre + pre_pre</span><br><span class="line">        pre_pre = pre</span><br><span class="line">        pre = res</span><br><span class="line">    <span class="keyword">return</span> res % <span class="number">1000000007</span></span><br><span class="line">        </span><br><span class="line">t1 = <span class="built_in">int</span>(<span class="built_in">round</span>(time.time() * <span class="number">1000</span>))</span><br><span class="line">res = fib(<span class="number">20</span>)</span><br><span class="line">t2 = <span class="built_in">int</span>(<span class="built_in">round</span>(time.time() * <span class="number">1000</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;the res is &#123;0&#125; use time is &#123;1&#125;&quot;</span>.<span class="built_in">format</span>(res,(t2-t1)))</span><br></pre></td></tr></table></figure><h5 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h5><p><strong>题目</strong>:</p><p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>注意：</strong>给定 <em>n</em> 是一个正整数。</p><p><strong>思路</strong>: 我们仔细思考这道题会发现其实跟斐波那契是一个类型的题目，当阶梯为1和0的时候，只有1种走法(1)，当阶梯为2的时候，有2种走法(1-&gt;1, 2)，当阶梯为3的是时候，有三种走法(1-&gt;1-&gt;1, 1-&gt;2, 2-&gt;1)，当阶梯为n的时候，有f(n-1)+f(n-2)种走法，因此可以转发为斐波那契数列问题处理，代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">claim_stairs</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">or</span> n==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    pre = <span class="number">1</span></span><br><span class="line">    pre_pre = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">        res = pre_pre+pre</span><br><span class="line">        pre_pre = pre</span><br><span class="line">        pre = res</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h5 id="三角形最小路径和"><a href="#三角形最小路径和" class="headerlink" title="三角形最小路径和"></a>三角形最小路径和</h5><p><strong>题目:</strong></p><p>给定一个三角形 triangle ，找出自顶向下的最小路径和。</p><p>每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 </p><p>输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]<br>输出：11<br>解释：如下面简图所示：<br>   2<br>  3 4<br> 6 5 7<br>4 1 8 3<br>自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。</p><p><strong>思路:</strong></p><h5 id><a href="#" class="headerlink" title></a></h5>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h4 id=&quot;动态规划算法&quot;&gt;&lt;a href=&quot;#动态规划算法&quot; class=&quot;headerlink&quot; title=&quot;动态规划算法&quot;&gt;&lt;/a&gt;动态规划算法&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;动态规划算法是通过拆分问题</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux相关</title>
    <link href="http://example.com/2021/04/11/Linux%E7%9B%B8%E5%85%B3/"/>
    <id>http://example.com/2021/04/11/Linux%E7%9B%B8%E5%85%B3/</id>
    <published>2021-04-11T14:45:47.000Z</published>
    <updated>2021-04-20T13:33:01.925Z</updated>
    
    
    
    
    <category term="Linux相关" scheme="http://example.com/categories/Linux%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="Linux相关" scheme="http://example.com/tags/Linux%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>中间件</title>
    <link href="http://example.com/2021/04/11/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <id>http://example.com/2021/04/11/%E4%B8%AD%E9%97%B4%E4%BB%B6/</id>
    <published>2021-04-11T14:45:38.000Z</published>
    <updated>2021-05-22T08:14:30.646Z</updated>
    
    
    
    
    <category term="中间件" scheme="http://example.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="中间件" scheme="http://example.com/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>项目</title>
    <link href="http://example.com/2021/04/11/%E9%A1%B9%E7%9B%AE/"/>
    <id>http://example.com/2021/04/11/%E9%A1%B9%E7%9B%AE/</id>
    <published>2021-04-11T14:45:30.000Z</published>
    <updated>2021-04-13T13:47:34.464Z</updated>
    
    
    
    
    <category term="项目" scheme="http://example.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="项目" scheme="http://example.com/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>算法</title>
    <link href="http://example.com/2021/04/11/%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2021/04/11/%E7%AE%97%E6%B3%95/</id>
    <published>2021-04-11T14:45:23.000Z</published>
    <updated>2021-04-13T13:47:25.403Z</updated>
    
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Python</title>
    <link href="http://example.com/2021/04/11/Python/"/>
    <id>http://example.com/2021/04/11/Python/</id>
    <published>2021-04-11T14:45:12.000Z</published>
    <updated>2021-04-13T13:48:32.657Z</updated>
    
    
    
    
    <category term="Python" scheme="http://example.com/categories/Python/"/>
    
    
    <category term="Python" scheme="http://example.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="http://example.com/2021/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>http://example.com/2021/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</id>
    <published>2021-04-11T14:33:36.000Z</published>
    <updated>2021-05-22T09:26:17.817Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h3 id="计算机分层"><a href="#计算机分层" class="headerlink" title="计算机分层"></a>计算机分层</h3><ol><li><p>目前市面上存在的有OSI七层模型,TCP/IP四层协议，以及五层协议，如图所示:</p><p><img src="/2021/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82.png" alt="不同网络分层"></p></li><li><p>我们以标准的OSI七层模型为例，自下向上的阐述一下每层的作用 </p><p><img src="/2021/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B.png" alt="OSI七层模型"></p><ul><li><p><strong>物理层</strong></p><p>机械，电子，定时接收通信信道上的原始比特流,主要定义了一些物理设备的标准 ，如网线的类型，光纤接口的类型，主要作用是传输比特流，即我们说的0101数据，将他们转换成电流 强弱传输(数模转换)，网卡工作在这一层</p></li><li><p><strong>数据链路层</strong></p><p>将比特流封装成帧发送，并且这一层还提供了差错检测机制(即发送比特流的过程中可能会发生误传重传或者错传的情况)，交换机工作在这一层</p></li><li><p><strong>网络层</strong></p><p>点对点发送时可能需要经过多个节点，那么他是如何找到正确的目标地址的呢?这时便有了网络层,控制子网的运行，如逻辑编址，分组传输，路由传输。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 <strong>IP 协议</strong>，因此分组也叫 <strong>IP 数据报</strong> ，简称 <strong>数据报</strong>。</p><p>这里要注意：<strong>不要把运输层的“用户数据报 UDP ”和网络层的“ IP 数据报”弄混</strong>。另外，无论是哪一层的数据单元，都可笼统地用“分组”来表示。</p><p>这里强调指出，网络层中的“网络”二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称。路由器便工作在这一层</p></li><li><p><strong>传输层</strong></p><p>接受上一层的数据，在必要的时候把数据进行分割，并且将这些数据交给网络层，且保证这些数据段能有效的到达对端 ，该层有两个重要的协议分别是TCP协议和UDP协议</p></li><li><p><strong>会话层</strong></p><p>不同机器上的用户之间建立以及管理会话</p></li><li><p><strong>表示层</strong></p><p>信息的语法语义以及他们的关联，如加密解密，转换翻译，压缩解压缩等等</p></li><li><p><strong>应用层</strong></p><p>**应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。**应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如**域名系统DNS**，支持万维网应用的 <strong>HTTP协议</strong>，支持电子邮件的 <strong>SMTP协议</strong>等等。我们把应用层交互的数据单元称为报文</p><p><strong>域名系统</strong></p><blockquote><p>域名系统(Domain Name System缩写 DNS，Domain Name被译为域名)是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。（百度百科）例如：一个公司的 Web 网站可看作是它在网上的门户，而域名就相当于其门牌地址，通常域名都使用该公司的名称或简称。例如上面提到的微软公司的域名，类似的还有：IBM 公司的域名是 <a href="http://www.ibm.com、oracle/">www.ibm.com、Oracle</a> 公司的域名是 <a href="http://www.oracle.com、cisco公司的域名是/">www.oracle.com、Cisco公司的域名是</a> <a href="http://www.cisco.com/">www.cisco.com</a> 等。</p></blockquote><p><strong>HTTP协议</strong></p><blockquote><p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW（万维网） 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。（百度百科）</p></blockquote></li></ul></li></ol><ol start="3"><li><p>不同层次的简要配合流程:</p><p><img src="/2021/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%AF%8F%E5%B1%82%E5%B7%A5%E4%BD%9C%E4%BD%9C%E7%94%A8.png" alt="工作流程"></p></li></ol><h3 id="TCP三次握手与四次挥手机制"><a href="#TCP三次握手与四次挥手机制" class="headerlink" title="TCP三次握手与四次挥手机制"></a>TCP三次握手与四次挥手机制</h3><ol><li><p><strong>传输控制协议TCP简介</strong></p><ul><li>面向连接的，可靠的，基于字节流的传输层通信协议</li><li>将应用层的数据流分割成报文段并发送给目标节点的TCP层</li><li>数据包都有序号，对方收到则发送ACK确认，未收到则重传</li><li>使用校验和检验数据在传输过程中是否有误 </li></ul></li><li><p><strong>TCP的报文结构如图所示:</strong></p><p><img src="/2021/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/tcp%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84.png" alt="tcp三次握手"></p></li></ol><ul><li><p>序列号seq：占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。</p></li><li><p>确认号ack：占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。</p></li><li><p>确认ACK：占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效</p></li><li><p>同步SYN：连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。</p></li><li><p>终止FIN：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接</p></li><li><p>PS：ACK、SYN和FIN这些大写的单词表示标志位，其值要么是1，要么是0；ack、seq小写的单词表示序号</p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>URG</td><td>紧急指针是否有效。为1，表示某一位需要被优先处理</td></tr><tr><td>ACK</td><td>确认号是否有效，一般置为1</td></tr><tr><td>PSH</td><td>提示接收端应用程序立即从TCP缓冲区把数据读走</td></tr><tr><td>RST</td><td>对方要求重建建立，复位</td></tr><tr><td>SYN</td><td>请求建立连接，并且在其序列号的字段进行序列号的初始值设定。建立连接，设置为1</td></tr><tr><td>FIN</td><td>希望断开连接</td></tr></tbody></table></li></ul><ol start="3"><li><strong>tcp三次握手</strong></li></ol><p><img src="/2021/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="tcp三次握手"></p><ul><li><p>第一次握手: 建立连接时，客户端会发送一个syn=j包和一个seq=x包到服务端,并且进去到SYN_SENT状态，等待服务端确认</p></li><li><p>第二次握手: 服务端收到来自客户端的syn包，必须确认客户端的SYN(ack=j+1),并且发送自己的seq=y包，即SYN+ACK包，此时服务端进入到SYN_RECV状态</p></li><li><p>第三次握手: 客户端收到来自服务端的ACK+SYN包，向服务器发送确认包ACK(ack=y+1),此包发送完毕，双方都进入到ESTABLISHED（TCP连接成功）状态，完成三次握手</p></li></ul><ol start="4"><li><p><strong>tcp四次挥手</strong></p><p><img src="/2021/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="四次挥手"></p><ul><li><p><strong>第一次</strong>: 客户端发送一个FIN，用来关闭客户端到服务端的数据传输，客户端进入到FIN_WAIT_1状态</p></li><li><p><strong>第二次</strong>:服务端收到FIN后，发送一个ACK给客户端，确认序列号为收到的序号+1（与SYN相同，一个FIN占用一个序号），Server进入到CLOSE_WAIT状态</p></li><li><p><strong>第三次</strong>: 服务端发送一个FIN，用来关闭服务端到客户端的数据传输，服务端进入到LAST_ACK状态</p></li><li><p><strong>第四次:</strong> 客户端收到FIN后，客户端进入到TIME_WAIT状态，接着发送一个ACK给服务端，确认序号为收到的序号+1,服务端进入到CLOSED状态，完成四次挥手</p></li></ul><ol start="5"><li><p>【<strong>常见问题</strong>】</p><ul><li><p>【问题1】<strong>TCP连接必须经过2MSL后才真正释放掉，为什么 需要等待2MSL的时间段的TIME_WAIT状态再进入到CLOSE状态而不是立马就进入到CLOSE状态?</strong></p><ul><li><p>确保有足够的时间让对方收到ACK包。如果被动关闭的那一端没有收到ACK包，那么就会触发被动关闭方重发FIN包，一来一回刚好是2MSL的时间段</p></li><li><p>避免新旧连接混淆。有些路由器会缓存数据包，如果连接被重用了，那么那些延迟收到的包就有可能会跟新的数据包混淆在一起</p></li></ul></li><li><p>【问题2】<strong>为什么是需要四次握手才能断开连接？而建立连接确实三次握手？</strong></p><ul><li>因为全双工，发送方和接收方都需要FIN和ACK报文。</li><li>当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手</li></ul></li><li><p>【问题3】<strong>为什么不能两次握手建立连接？</strong></p><ul><li><p>3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。</p></li><li><p><strong>为了初始化Sequence Number的初始值。</strong>现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。</p></li></ul></li><li><p>【问题4】<strong>如果已经建立了连接，但是客户端突然出现故障下线了怎么办(即所谓的SYN flood攻击)？</strong></p><ul><li>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</li></ul></li><li><p>【问题5】<strong>服务器产生大量的time_wait怎么办?</strong></p><ul><li><p>首先大量的TIME_WAIT造成的影响?</p><ul><li><p> 在<strong>高并发短连接</strong>的TCP服务器上，当服务器处理完请求后立刻主动正常关闭连接。这个场景下会出现大量socket处于TIME_WAIT状态。如果客户端的并发量持续很高，此时部分客户端就会显示连接不上。</p></li><li><p>那么怎么去处理这种情况呢?</p><ul><li><p>首先我们可以用linux命令去查看TCP的连接数:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">netstat -ant|awk &#39;&#x2F;^tcp&#x2F; &#123;++S[$NF]&#125; END &#123;for(a in S) print (a,S[a])&#125;&#39;</span><br><span class="line">LAST_ACK 14</span><br><span class="line">SYN_RECV 348</span><br><span class="line">ESTABLISHED 70</span><br><span class="line">FIN_WAIT1 229</span><br><span class="line">FIN_WAIT2 30</span><br><span class="line">CLOSING 33</span><br><span class="line">TIME_WAIT 18122</span><br></pre></td></tr></table></figure></li></ul></li><li><p>状态描述:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CLOSED：无连接是活动的或正在进行</span><br><span class="line">LISTEN：服务器在等待进入呼叫</span><br><span class="line">SYN_RECV：一个连接请求已经到达，等待确认</span><br><span class="line">SYN_SENT：应用已经开始，打开一个连接</span><br><span class="line">ESTABLISHED：正常数据传输状态</span><br><span class="line">FIN_WAIT1：应用说它已经完成</span><br><span class="line">FIN_WAIT2：另一边已同意释放</span><br><span class="line">ITMED_WAIT：等待所有分组死掉</span><br><span class="line">CLOSING：两边同时尝试关闭</span><br><span class="line">TIME_WAIT：另一边已初始化一个释放</span><br><span class="line">LAST_ACK：等待所有分组死掉</span><br></pre></td></tr></table></figure></li><li><p>编辑内核文件/etc/sysctl.conf,加入以下内容:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_syncookies &#x3D; 1 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；</span><br><span class="line">net.ipv4.tcp_tw_reuse &#x3D; 1 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；</span><br><span class="line">net.ipv4.tcp_tw_recycle &#x3D; 1 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。</span><br><span class="line">net.ipv4.tcp_fin_timeout 修改系默认的 TIMEOUT 时间</span><br></pre></td></tr></table></figure></li><li><p>然后执行 /sbin/sysctl -p 让参数生效.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;sysctl.conf是一个允许改变正在运行中的Linux系统的接口，它包含一些TCP&#x2F;IP堆栈和虚拟内存系统的高级选项，修改内核参数永久生效。</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>上面的配置简单来说，就是打开系统的TIMEWAIT的重用和快速回收</p></li><li><p>如果以上配置调优后性能还是不理想，可继续修改一下配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;sysctl.conf</span><br><span class="line">net.ipv4.tcp_keepalive_time &#x3D; 1200 </span><br><span class="line">#表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为20分钟。</span><br><span class="line">net.ipv4.ip_local_port_range &#x3D; 1024 65000 </span><br><span class="line">#表示用于向外连接的端口范围。缺省情况下很小：32768到61000，改为1024到65000。</span><br><span class="line">net.ipv4.tcp_max_syn_backlog &#x3D; 8192 </span><br><span class="line">#表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数。</span><br><span class="line">net.ipv4.tcp_max_tw_buckets &#x3D; 5000 </span><br><span class="line">#表示系统同时保持TIME_WAIT套接字的最大数量，如果超过这个数字，TIME_WAIT套接字将立刻被清除并打印警告信息。</span><br><span class="line">默认为180000，改为5000。对于Apache、Nginx等服务器，上几行的参数可以很好地减少TIME_WAIT套接字数量，但是对于 Squid，效果却不大。此项参数可以控制TIME_WAIT套接字的最大数量，避免Squid服务器被大量的TIME_WAIT套接字拖死。</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li></ol></li></ol><h3 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h3><ul><li><p><strong>UDP的特点</strong>:</p><ul><li>面向非连接</li><li>不维护连接状态，支持同时向多个客户端传输相同的消息</li><li> 数据包报头只有8个字节，额外开销较小</li><li>吞吐量只受限于数据生成率，传输速率以及机器性能</li></ul></li><li><p>尽最大努力交付，不保证可靠交付，不需要维持复杂的链接状态表</p></li><li><p><strong>UDP报文结构</strong>(报文头部8个字节)</p><p><img src="/2021/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/UDP%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84.png" alt="UDP报文结构"></p></li><li><p>TCP报文结构（报文头部20个字节）</p><p><img src="/2021/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/tcp%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84.png" alt="TCP报文结构"></p></li><li><p> <strong>两者区别</strong></p></li><li><p>TCP面向连接，而UDP面向无连接</p></li><li><p>TCP相对于UDP来说可靠性要高，因为TCP是有连接机制（<strong>可靠性</strong>）</p></li><li><p>TCP是有序的而UDP是无序的(<strong>有序性</strong>)</p></li><li><p>TCP较UDP来说速度较慢，因为TCP要握手挥手机制，UDP适合 对速度比较敏感的应用，如在线直播等(<strong>速度</strong>)</p></li><li><p>TCP(头部20字节)在量级上比UDP(头部8字节)要小(<strong>量级</strong>)</p></li></ul><h3 id="TCP的滑动窗口"><a href="#TCP的滑动窗口" class="headerlink" title="TCP的滑动窗口"></a>TCP的滑动窗口</h3><ol><li><strong>我们先来理解两个概念RTT和RTO</strong></li></ol><ul><li>RTT: 发送一个数据包到收到对应的ACK所花费的时间</li><li>RTO:重传时间间隔  </li><li>滑动窗口基于RTO</li></ul><ol start="2"><li><strong>TCP使用滑动窗口做流量控制与乱序重排</strong></li></ol><ul><li>保证TCP的可靠性</li><li>保证TCP的流控特性</li><li>报头的window：用于接收方通知发送方，自己还有多少缓冲区用来接收数据，发送方根据接收方的处理能力来发送数据，不会导致接收方处理不过来。</li></ul><p><img src="/2021/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B.png" alt="窗口数据的计算过程"></p><ul><li><p>名词解释</p><p>LastByteWritten:上层应用最后一个写的数据，即当前程序准备好要发送的最新的一个数据（还没发送）</p><p>LastByteAcked：最后一个ACK(确认收到)的数据</p><p>LastByteSent：最后一个已经发送的数据，还没收到ack</p><p>LastByteRead：接收端，读取到的并且已经处理的最后一条数据（已经回复ACK的）</p><p>NextByteExpected：已经收到的连续数据中最大的一条（还没回复ACK的）</p><p>LastByteRecvd：已收到的最后一条数据（不连续）</p></li><li><p>窗口数据的计算过程</p><ol><li><p><strong>接收方计算AdvertisedWindow</strong>：</p><ul><li><p>AdvertisedWindow:建议发送端发送的最大数据量</p></li><li><p>AdvertisedWindow = MaxRcvBuffer - (LastByteRecvd-LastByteRead)</p></li><li><p>MaxRcvBuffer接收端缓存池大小</p></li></ul></li><li><p><strong>将AdvertisedWindow发送到发送方，发送方根据AdvertisedWindow计算EffectiveWindow</strong></p><ul><li>EffectiveWindow：发送方窗口内，剩余可发送的最大数据量</li><li>EffectiveWindow = AdvertisedWindow - (LastByteSent-LastByteAcked)</li></ul></li></ol></li><li><p><strong>滑动窗口的基本原理(滑动窗口要比(接收，发送)缓存小)</strong></p></li></ul><ol><li><strong>TCP发送方</strong>:滑动窗口：Category#2 + Category#3,当发送方收到接收方的数据ack时,窗口就会滑动。</li></ol><p><img src="/2021/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E5%8F%91%E9%80%81%E6%96%B9.png" alt="TCP发送方"></p><ol start="2"><li><strong>TCP接收方</strong>:接收窗口：Category#3,当接收方收到连续的数据后并且发出ACK信号后，窗口就会滑动<img src="/2021/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E6%8E%A5%E6%94%B6%E6%96%B9.png" alt="TCP接受方"></li></ol><ul><li><strong>最后总结:</strong><ul><li>流量控制:<ul><li>滑动窗口的大小可以依据一定策略动态调整，应用会根据自身处理能力的变化，通过本端TCP接收窗口的大小的控制，实现对端的发送窗口改变进行流量控制。</li><li>接收方通过计算得出AdvertisedWindow，并发送给发送方。</li><li>发送方：根据AdvertisedWindow计算可发送最大的数据量EffectiveWindow。</li></ul></li><li>乱序控制:<ul><li>接收方：按连续顺序确认接收并发送ack信号。</li><li>发送方  ：按连续顺序发送数据。</li></ul></li></ul></li></ul><h3 id="HTTP相关"><a href="#HTTP相关" class="headerlink" title="HTTP相关"></a>HTTP相关</h3><ol><li><p><strong>超文本传输协议HTTP的主要特点:</strong></p><ul><li>支持客户/服务器模式</li><li>简单快速</li><li>灵活</li><li>无连接 </li><li>无状态 </li></ul></li><li><p><strong>HTTP请求结构</strong>：</p><ul><li>请求行</li><li>请求头</li><li>空行(即便请求正文没有，也要有一行空行表示请求头结束 )</li><li>请求正文</li></ul><p><img src="/2021/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E8%AF%B7%E6%B1%82%E7%BB%93%E6%9E%84.png" alt="HTTP请求结构"></p></li><li><p><strong>HTTP响应报文结构:</strong></p><ul><li>响应行</li><li>响应头</li><li>空行</li><li>响应正文</li></ul></li><li><p><strong>请求/响应的步骤</strong>:</p><ul><li>客户端连接到WEB服务器</li><li>发送HTTP请求</li><li>服务器接受请求并返回HTTP响应</li><li>释放连接TCP连接</li><li>客户端浏览器解析HTML内容</li></ul></li><li><p><strong>在浏览器地址栏键入URL，按下回车之后经历的流程:</strong></p><ul><li>DNS解析(浏览器缓存-&gt;系统缓存-&gt;路由器缓存-&gt;IPS服务器缓存-&gt;根域名服务器缓存-&gt;顶级域名器缓存）以此查找</li><li>TCP连接，即三次握手机制</li><li>发送HTTP请求</li><li>服务器处理HTTP请求并返回HTTP报文</li><li>浏览器解析渲染页面</li><li>连接结束，即四次挥手机制</li></ul></li><li><p><strong>HTTP状态码:</strong></p><ul><li>1XX：指示请求—表示请求已接收，继续处理</li><li>2XX: 成功–表示请求已经被成功接收，理解，接受</li><li>3XX：重定向–要完成请求必须进行更进一步的操作</li><li>4XX:客户端错误–请求有语法错误或者请求无法实现</li><li>5XX:服务端错误–服务器未能实现合法的请求</li></ul></li><li><p><strong>HTTP和HTTPS的区别:</strong></p><ul><li><p>HTTPS简介:可以理解成HTTPS=HTTP+SSL</p><p><img src="/2021/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS%E7%AE%80%E4%BB%8B.png" alt="HTTPS简介"></p></li><li><p>SSL简介(安全套接层):</p><ul><li><p> 为网络通信提供了安全以及数据完整性的一种安全协议</p></li><li><p>是操作系统对外的API，SSL3.0后更名为TLS</p></li><li><p>采用身份验证和数据加密保证网络通信的安全和数据的完整性</p><ul><li><p>加密的方式</p><ol><li>对称加密:加密和解密都使用同一个密钥(效率高，但不安全)(AES)</li><li>不对称加密:加密使用的密钥和解析使用的密钥是不同的(效率低，但安全性高)(RSA)</li><li>哈希算法:将任意长度的信息转换成固定长度的值，算法不可逆(MD5)</li><li>数字签名:证明某个消息或者文件是某人发出/认同的</li></ol></li><li><p><strong>HTTPS请求过程</strong>:</p><ul><li><p>首先，数据正文一般数据量较大，适用于对称加密，因为对称加密速度快，适应于大量数据加密，但是安全级别低，其中对称加密的密钥需要在网络中传输，容易被盗取；</p></li><li><p>其次，正因为对称加密的密钥易被盗取，所以我们需要对这个密钥进行加密，而且安全级别要求高，所以这个可以用非对称加密算法进行加密，原因是对称加密的密钥数据量小，非对称加密可以提供高安全级别和高响应速度</p><p><img src="/2021/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTPS%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B.png" alt="HTTPS请求过程"></p><ol><li>客户端向服务器发起HTTPS的请求，连接到服务器的443端口</li><li>服务器将非对称加密的公钥以证书的形式回传给客户端</li><li>客户端接受到该公钥后进行验证，就是验证步骤2中服务器返回的证书，如果有问题，则HTTPS请求无法继续；如果没有问题，则上述公钥是合格的，客户端这个时候随机生成一个密钥，称为client key(客户端密钥)，即用于对称加密数据的密钥，然后使用前面的公钥对client key进行非对称加密成密文，至此，HTTPS中的第一次HTTP请求结束</li><li>客户端发起第二次HTTP请求，将加密之后的client key发送给服务器</li><li>服务器使用私钥进行解密，得到解密后的client key，然后使用client key对数据进行对称加密；</li><li>将对称加密后的数据发送给客户端，客户端收到后对密文进行对称解密，得到服务器发送的数据，这样HTTPS中的第二次HTTP请求结束。HTTPS请求完成。</li></ol></li></ul></li></ul></li><li><p><strong>区别总结:</strong></p><ul><li>HTTPS是密文传输，HTTP是明文传输；</li><li>默认连接的端口号是不同的，HTTPS是443端口，而HTTP是80端口；</li><li>HTTPS请求的过程需要对CA证书进行验证身份以保证客户端请求到正确的服务器端，传回的响应是来自于正确的服务器端，而HTTP则不需要CA证书；</li><li>HTTPS=HTTP+加密+认证+完整性保护</li></ul></li><li><p><strong>HTTPS真的很安全吗?</strong></p><ul><li><p>未必，可能发生<strong>中间人攻击</strong></p><p><img src="/2021/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB.png" alt="中间人攻击"></p></li></ul></li><li><p><strong>那么如何预防中间人攻击呢?</strong></p><ul><li>那么就需要一个强大的CA机构了，因为正经的 CA 证书，都是来自某个权威的 CA。如果某个 CA 足够权威，那么主流的操作系统（或浏览器）会内置该 CA 的“根证书”。（比如 Windows 中就内置了几十个权威 CA 的根证书）因此，浏览器就可以利用系统内置的根证书，来判断网站发过来的 CA 证书是不是某个 CA 颁发的。</li></ul></li></ul></li></ul></li></ol><p>​     </p><p>​     </p><p>​     </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h3 id=&quot;计算机分层&quot;&gt;&lt;a href=&quot;#计算机分层&quot; class=&quot;headerlink&quot; title=&quot;计算机分层&quot;&gt;&lt;/a&gt;计算机分层&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;目前市面上存在的有OSI七层模型,TCP/IP四层协议，以及五层协议，如</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>java</title>
    <link href="http://example.com/2021/04/11/java/"/>
    <id>http://example.com/2021/04/11/java/</id>
    <published>2021-04-11T12:46:24.000Z</published>
    <updated>2021-04-13T13:48:04.906Z</updated>
    
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
</feed>
